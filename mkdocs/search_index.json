{
    "docs": [
        {
            "location": "/", 
            "text": "Angular Cheat Sheet", 
            "title": "Home"
        }, 
        {
            "location": "/component/", 
            "text": "@Component\n\n\nA class becomes am Angular Component when we give it Component Metadata. We do so by attaching a Decorator (@). A Decorator is a function that adds metadata to a class, it's member, or its method arguments.\n\n\nimport\n \n{\n \nComponent\n \n}\n \nfrom\n \n@angular/core\n;\n\n\n\n@Component\n({\n\n  \nmodule\nId\n:\n \nmodule\n.id\n,\n\n  \nselector\n:\n \nmy-app\n,\n\n  \ntemplate\n:\n \n`\n\n\n    \nh1\n{{PageTitle}}\n/h1\n\n\n    \np\nThis is a Component\n/p\n\n\n  `\n,\n\n  \nstyles\n:\n \n[\n.primary {color: red}\n]\n\n\n})\n\n\nexport\n \nclass\n \nAppComponent\n \n{\n\n  \npageTitle\n: \nstring\n \n=\n \nMy First Component\n;\n\n\n}\n\n\n\n\n\n\napp.module.ts\n\n\n\n@NgModule\n({\n\n\n  \ndeclarations\n:\n \n[\n \nMoviesComponent\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nAppModule\n \n{\n \n}\n\n\n\n\n\n\nUse \nPascalCasing\n and append \nComponent\n to the class name.\n\n\nClass' properties and methods use camelCase.\n\n\nMetadata Properties\n\n\n\n\nanimations\n: list of animations of this component.\n\n\nchangeDetection\n: change detection strategy used by this component.\n\n\nencapsulation\n: style encapsulation strategy used by this component.\n\n\nentryComponents\n: list of components that are dynamically inserted into the view of this component.\n\n\nexportAs\n: name under which the component instance is exported in a template.\n\n\nhost\n: map of class property to host element bindings for events, properties and attributes.\n\n\ninputs\n: list of class property names to data-bind as component inputs.\n\n\ninterpolation\n: custom interpolation markers used in this component's template.\n\n\nmoduleId: module.id\n If set, the \ntemplateUrl\n and \nstyleUrl\n are resolved relative to the component.\n\n\noutputs\n: list of class property names that expose output events that others can subscribe to.\n\n\nproviders\n: list of providers available to this component and its children.\n\n\nqueries\n: configure queries that can be injected into the component.\n\n\nselector:\n Specifies a CSS selector that identifies this directive within a template. Supported selectors include \nelement\n, \n[attribute]\n, \n.class\n, and \n:not()\n. Does not support parent-child relationship selectors.\n\n\nstyles: ['.primary {color: red}']\n List of inline CSS styles for styling the component\u2019s view.\n\n\nstyleUrls: ['my-component.css']\n List of external stylesheet URLs for styling the component\u2019s view.\n\n\ntemplate: 'Hello {{name}}'\n Inline template URL of the component's view.\n\n\ntemplateUrl: 'my-component.html'\n External template URL of the component's view.\n\n\nviewProviders: [MyService, { provide: ... }]\n List of dependency injection providers scoped to this component's view.", 
            "title": "@Component"
        }, 
        {
            "location": "/component/#component", 
            "text": "A class becomes am Angular Component when we give it Component Metadata. We do so by attaching a Decorator (@). A Decorator is a function that adds metadata to a class, it's member, or its method arguments.  import   {   Component   }   from   @angular/core ;  @Component ({ \n   module Id :   module .id , \n   selector :   my-app , \n   template :   `       h1 {{PageTitle}} /h1       p This is a Component /p    ` , \n   styles :   [ .primary {color: red} ]  })  export   class   AppComponent   { \n   pageTitle :  string   =   My First Component ;  }   app.module.ts  @NgModule ({     declarations :   [   MoviesComponent   ]  })  export   class   AppModule   {   }   Use  PascalCasing  and append  Component  to the class name.  Class' properties and methods use camelCase.", 
            "title": "@Component"
        }, 
        {
            "location": "/component/#metadata-properties", 
            "text": "animations : list of animations of this component.  changeDetection : change detection strategy used by this component.  encapsulation : style encapsulation strategy used by this component.  entryComponents : list of components that are dynamically inserted into the view of this component.  exportAs : name under which the component instance is exported in a template.  host : map of class property to host element bindings for events, properties and attributes.  inputs : list of class property names to data-bind as component inputs.  interpolation : custom interpolation markers used in this component's template.  moduleId: module.id  If set, the  templateUrl  and  styleUrl  are resolved relative to the component.  outputs : list of class property names that expose output events that others can subscribe to.  providers : list of providers available to this component and its children.  queries : configure queries that can be injected into the component.  selector:  Specifies a CSS selector that identifies this directive within a template. Supported selectors include  element ,  [attribute] ,  .class , and  :not() . Does not support parent-child relationship selectors.  styles: ['.primary {color: red}']  List of inline CSS styles for styling the component\u2019s view.  styleUrls: ['my-component.css']  List of external stylesheet URLs for styling the component\u2019s view.  template: 'Hello {{name}}'  Inline template URL of the component's view.  templateUrl: 'my-component.html'  External template URL of the component's view.  viewProviders: [MyService, { provide: ... }]  List of dependency injection providers scoped to this component's view.", 
            "title": "Metadata Properties"
        }, 
        {
            "location": "/ngModules/", 
            "text": "NgModules help organize an application into cohesive blocks of functionality.\n\n\nModules are a great way to organize an application and extend it with capabilities from external libraries.\n\n\nAn NgModule is a class decorated with \n@NgModule\n metadata. The metadata do the following:\n\n\n\n\nDeclare which components, directives, and pipes belong to the module.\n\n\nMake some of those classes public so that other component templates can use them.\n\n\nImport other modules with the components, directives, and pipes needed by the components in \nthis\n module.\n\n\nProvide services at the application level that any application component can use.\n\n\n\n\nEvery Angular app has at least one module class, the \nroot module\n. You bootstrap that module to launch the application. The root module is all you need in a simple application with a few components. As the app grows, you refactor the root module into \nfeature modules\n that represent collections of related functionality. You then import these modules into the root module.\n\n\nsrc/app/app.module.ts\n\n\n\nimport\n \n{\n \nNgModule\n \n}\n \nfrom\n \n@angular/core\n;\n\n\nimport\n \n{\n \nBrowserModule\n \n}\n \nfrom\n \n@angular/platform-browser\n;\n\n\nimport\n \n{\n \nAppComponent\n \n}\n \nfrom\n \n./app.component.ts\n;\n\n\n\n@NgModule\n({\n\n  \nimports\n:\n \n[\n\n    \nBrowserModule\n,\n\n    \nFormsModule\n,\n\n    \nRouterModule\n.\nforRoot\n(\nappRoutes\n,\n \n{\n \nenableTracing\n: \ntrue\n \n})\n\n  \n],\n\n  \ndeclarations\n:\n \n[\n\n    \nAppComponent\n,\n\n    \nMoviesComponent\n,\n\n    \nMovieDetailComponent\n,\n\n    \nMovieFilterPipe\n\n  \n],\n\n  \nproviders\n:\n \n[\n \nMovieDetailGuard\n \n],\n\n  \nexports\n:\n \n[\n \nMovieDetailComponent\n \n],\n\n  \nbootstrap\n:\n \n[\n \nAppComponent\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nAppModule\n \n{\n \n}\n\n\n\n\n\n\nBootstrap Array\n\n\nit defines the Component that is the starting point of the application. This Component is the \nApplication Component.\n\n\nThe bootstrap array should only be used in the AppModule.\n\n\nDeclarations Array\n\n\nIt's used to define the \nComponents\n, \nDirectives\n and \nPipes\n that belong to the Module.\n\n\nEvery component, directive, and pipe belong to \none and only one\n Angular module. Also, they are private by default (they can be exported if needed).\n\n\nExports Array\n\n\nAllows us to share the \nComponents\n, \nDirectives\n and \nPipes\n with modules that import this module.\n\n\nImports Array\n\n\nAllows us to import supporting modules that export \nComponents\n, \nDirectives\n or \nPipes\n to be used on within components that are declared in this module.\n\n\nImporting a module does NOT provide access to its imported modules. In other words, imports are not inherited.\n\n\nProviders Array\n\n\nAllows us to register service providers at the module level.", 
            "title": "@ngModule(s)"
        }, 
        {
            "location": "/ngModules/#bootstrap-array", 
            "text": "it defines the Component that is the starting point of the application. This Component is the  Application Component.  The bootstrap array should only be used in the AppModule.", 
            "title": "Bootstrap Array"
        }, 
        {
            "location": "/ngModules/#declarations-array", 
            "text": "It's used to define the  Components ,  Directives  and  Pipes  that belong to the Module.  Every component, directive, and pipe belong to  one and only one  Angular module. Also, they are private by default (they can be exported if needed).", 
            "title": "Declarations Array"
        }, 
        {
            "location": "/ngModules/#exports-array", 
            "text": "Allows us to share the  Components ,  Directives  and  Pipes  with modules that import this module.", 
            "title": "Exports Array"
        }, 
        {
            "location": "/ngModules/#imports-array", 
            "text": "Allows us to import supporting modules that export  Components ,  Directives  or  Pipes  to be used on within components that are declared in this module.  Importing a module does NOT provide access to its imported modules. In other words, imports are not inherited.", 
            "title": "Imports Array"
        }, 
        {
            "location": "/ngModules/#providers-array", 
            "text": "Allows us to register service providers at the module level.", 
            "title": "Providers Array"
        }, 
        {
            "location": "/built-in-directives/", 
            "text": "Built-in structural directives\n\n\n*ngIf\n\n\nhero-detail\n \n*\nngIf\n=\nisActive else elseBlock\n/\nhero-detail\n\n\nng-template\n \n#\nelseBlock\n\n  Alternate text (primary text is hidden)\n\n/\nng-template\n\n\n\n\n\n\nWhen the \nisActive\n expression returns a truthy value, \nNgIf\n adds the \nHeroDetailComponent\n to the DOM. When the expression is falsy, \nNgIf\n removes the \nHeroDetailComponent\n from the DOM, destroying that component and all of its sub-components.\n\n\nIf it is necessary to display a template when the \nexpression\n is falsy use the \nelse\n template binding as shown. Note that the \nelse\n binding points to a \nng-template\n labeled \n#elseBlock\n. The template can be defined anywhere in the component view but is typically placed right after \nngIf\n for readability.\n\n\n*ngFor\n\n\ndiv\n \n*\nngFor\n=\nlet hero of heroes; let i=index\n\n  {{ hero.name }} has an index of {{ i }}\n\n/\ndiv\n\n\n\n\n\n\nNgFor\n is a \nrepeater\n directive \u2014 a way to present a list of items. You define a block of HTML that defines how a single item should be displayed. You tell Angular to use that block as a template for rendering each item in the list.\n\n\nNgSwitch\n\n\ndiv\n \n[\nngSwitch\n]=\ncurrentHero\n.\nemotion\n\n  \nhappy-hero\n    \n*\nngSwitchCase\n=\nhappy\n/\nhappy-hero\n\n  \nsad-hero\n      \n*\nngSwitchCase\n=\nsad\n/\nsad-hero\n\n  \nconfused-hero\n \n*\nngSwitchCase\n=\nconfused\n/\nconfused-hero\n\n  \nunknown-hero\n  \n*\nngSwitchDefault\n/\nunknown-hero\n\n\n/\ndiv\n\n\n\n\n\n\nNgSwitch is like the JavaScript \nswitch\n statement. It can display \none\n element from among several possible elements, based on a \nswitch condition\n. Angular puts only the selected element into the DOM.\n\n\nBuilt-in attribute directives\n\n\nNgClass\n\n\ndiv\n \n[\nngClass\n]=\ncurrentClasses\n\n  This div is initially saveable, unchanged, and special\n\n/\ndiv\n\n\n\n\n\n\ncurrentClasses\n \n=\n  \n{\n\n  \nsaveable\n:\n \nthis\n.\ncanSave\n,\n\n  \nmodified\n:\n \n!\nthis\n.\nisUnchanged\n,\n\n  \nspecial\n:\n  \nthis\n.\nisSpecial\n\n\n};\n\n\n\n\n\n\nAdds and removes CSS classes on an HTML element.\n\n\nNgStyle\n\n\ndiv\n \n[\nngStyle\n]=\ncurrentStyles\n\n  This div is initially italic, normal weight.\n\n/\ndiv\n\n\n\n\n\n\ncurrentStyles\n \n=\n \n{\n\n  \nfont-style\n:\n \nthis\n.\ncanSave\n \n?\n \nitalic\n \n:\n \nnormal\n,\n\n  \nfont-weight\n:\n \n!\nthis\n.\nisUnchanged\n \n?\n \nbold\n \n:\n \nnormal\n,\n\n\n};\n\n\n\n\n\n\nUpdates an HTML element styles.\n\n\n[(NgModel)] - Two-way binding\n\n\ninput\n \n[(\nngModel\n)]=\ncurrentHero\n.\nname\n\n\n\n\n\n\nWhen developing data entry forms, you often both display a data property and update that property when the user makes changes. Two-way data binding with the \nNgModel\n directive makes that easy.\n\n\nBefore using the \nngModel\n directive in a two-way data binding, you must import the \nFormsModule\n and add it to the Angular module's \nimports\n.", 
            "title": "Built-in Directives"
        }, 
        {
            "location": "/built-in-directives/#built-in-structural-directives", 
            "text": "", 
            "title": "Built-in structural directives"
        }, 
        {
            "location": "/built-in-directives/#ngif", 
            "text": "hero-detail   * ngIf = isActive else elseBlock / hero-detail  ng-template   # elseBlock \n  Alternate text (primary text is hidden) / ng-template   When the  isActive  expression returns a truthy value,  NgIf  adds the  HeroDetailComponent  to the DOM. When the expression is falsy,  NgIf  removes the  HeroDetailComponent  from the DOM, destroying that component and all of its sub-components.  If it is necessary to display a template when the  expression  is falsy use the  else  template binding as shown. Note that the  else  binding points to a  ng-template  labeled  #elseBlock . The template can be defined anywhere in the component view but is typically placed right after  ngIf  for readability.", 
            "title": "*ngIf"
        }, 
        {
            "location": "/built-in-directives/#ngfor", 
            "text": "div   * ngFor = let hero of heroes; let i=index \n  {{ hero.name }} has an index of {{ i }} / div   NgFor  is a  repeater  directive \u2014 a way to present a list of items. You define a block of HTML that defines how a single item should be displayed. You tell Angular to use that block as a template for rendering each item in the list.", 
            "title": "*ngFor"
        }, 
        {
            "location": "/built-in-directives/#ngswitch", 
            "text": "div   [ ngSwitch ]= currentHero . emotion \n   happy-hero      * ngSwitchCase = happy / happy-hero \n   sad-hero        * ngSwitchCase = sad / sad-hero \n   confused-hero   * ngSwitchCase = confused / confused-hero \n   unknown-hero    * ngSwitchDefault / unknown-hero  / div   NgSwitch is like the JavaScript  switch  statement. It can display  one  element from among several possible elements, based on a  switch condition . Angular puts only the selected element into the DOM.", 
            "title": "NgSwitch"
        }, 
        {
            "location": "/built-in-directives/#built-in-attribute-directives", 
            "text": "", 
            "title": "Built-in attribute directives"
        }, 
        {
            "location": "/built-in-directives/#ngclass", 
            "text": "div   [ ngClass ]= currentClasses \n  This div is initially saveable, unchanged, and special / div   currentClasses   =    { \n   saveable :   this . canSave , \n   modified :   ! this . isUnchanged , \n   special :    this . isSpecial  };   Adds and removes CSS classes on an HTML element.", 
            "title": "NgClass"
        }, 
        {
            "location": "/built-in-directives/#ngstyle", 
            "text": "div   [ ngStyle ]= currentStyles \n  This div is initially italic, normal weight. / div   currentStyles   =   { \n   font-style :   this . canSave   ?   italic   :   normal , \n   font-weight :   ! this . isUnchanged   ?   bold   :   normal ,  };   Updates an HTML element styles.", 
            "title": "NgStyle"
        }, 
        {
            "location": "/built-in-directives/#ngmodel-two-way-binding", 
            "text": "input   [( ngModel )]= currentHero . name   When developing data entry forms, you often both display a data property and update that property when the user makes changes. Two-way data binding with the  NgModel  directive makes that easy.  Before using the  ngModel  directive in a two-way data binding, you must import the  FormsModule  and add it to the Angular module's  imports .", 
            "title": "[(NgModel)] - Two-way binding"
        }, 
        {
            "location": "/template-syntax/", 
            "text": "Interpolation (\n{{...}}\n)\n\n\nh3\n\n  {{title}}\n  \nimg\n \nsrc\n=\n{{heroImageUrl}}\n \nstyle\n=\nheight:30px\n\n\n/\nh3\n\n\n\n\n\n\nYou use interpolation to weave calculated strings into the text between HTML element tags and within attribute assignments.\n\n\nProperty binding (\n[property]\n)\n\n\nimg\n \n[\nsrc\n]=\nheroImageUrl\n\n\nbutton\n \n[\ndisabled\n]=\nisUnchanged\nCancel is disabled\n/\nbutton\n\n\n\n\n\n\nWrite a template property binding to set a property of a view element. The binding sets the property to the value of a template expression.\n\n\nAttribute, class, and style bindings\n\n\ntr\ntd\n \n[\nattr\n.\ncolspan\n]=\n1\n \n+\n \n1\nOne-Two\n/\ntd\n/\ntr\n\n\n\n\n\n\nThe \ntd\n element does not have a \ncolspan\n property. It has the \n\"colspan\"\n attribute, but interpolation and property binding can set only properties, not attributes. You need attribute bindings to create and bind to such attributes.\n\n\ndiv\n \n[\nclass\n.\nspecial\n]=\n!\nisSpecial\n\n  This one is not so special\n\n/\ndiv\n\n\n\n\n\n\nClass binding syntax resembles property binding. Instead of an element property between brackets, start with the prefix \nclass\n, optionally followed by a dot (.) and the name of a CSS class: \n[class.class-name]\n.\n\n\nbutton\n \n[\nstyle\n.\ncolor\n]=\nisSpecial\n \n?\n \nred\n:\n \ngreen\nRed\n/\nbutton\n\n\nbutton\n \n[\nstyle\n.\nbackground-color\n]=\ncanSave\n \n?\n \ncyan\n:\n \ngrey\n\n  Save\n\n/\nbutton\n\n\n\n\n\n\nStyle binding syntax resembles property binding. Instead of an element property between brackets, start with the prefix \nstyle\n, followed by a dot (.) and the name of a CSS style property: \n[style.style-property]\n.\n\n\nEvent binding (\n(event)\n)\n\n\nbutton\n \n(\nclick\n)=\nonSave\n()\nSave\n/\nbutton\n\n\n\n\n\n\nThe only way to know about a user action is to listen for certain events such as keystrokes, mouse movements, clicks, and touches. You declare your interest in user actions through Angular event binding.\n\n\nFor a list of events see \nhttps://developer.mozilla.org/en-US/docs/Web/Events\n\n\nThe safe navigation operator (\n?.\n)\n\n\ndiv\nThe current movie\ns name is {{movie?.name}}\n/\ndiv\n\n\n\n\n\n\nThe Angular safe navigation operator (\n?.\n) is a fluent and convenient way to guard against nulls in property paths. The expression bails out when it hits the first null value. The display is blank, but the app keeps rolling without errors.\n\n\nIt works perfectly with long property paths such as \na?.b?.c?.d\n.", 
            "title": "Template Syntax"
        }, 
        {
            "location": "/template-syntax/#interpolation", 
            "text": "h3 \n  {{title}}\n   img   src = {{heroImageUrl}}   style = height:30px  / h3   You use interpolation to weave calculated strings into the text between HTML element tags and within attribute assignments.", 
            "title": "Interpolation ({{...}})"
        }, 
        {
            "location": "/template-syntax/#property-binding-property", 
            "text": "img   [ src ]= heroImageUrl  button   [ disabled ]= isUnchanged Cancel is disabled / button   Write a template property binding to set a property of a view element. The binding sets the property to the value of a template expression.", 
            "title": "Property binding ([property])"
        }, 
        {
            "location": "/template-syntax/#attribute-class-and-style-bindings", 
            "text": "tr td   [ attr . colspan ]= 1   +   1 One-Two / td / tr   The  td  element does not have a  colspan  property. It has the  \"colspan\"  attribute, but interpolation and property binding can set only properties, not attributes. You need attribute bindings to create and bind to such attributes.  div   [ class . special ]= ! isSpecial \n  This one is not so special / div   Class binding syntax resembles property binding. Instead of an element property between brackets, start with the prefix  class , optionally followed by a dot (.) and the name of a CSS class:  [class.class-name] .  button   [ style . color ]= isSpecial   ?   red :   green Red / button  button   [ style . background-color ]= canSave   ?   cyan :   grey \n  Save / button   Style binding syntax resembles property binding. Instead of an element property between brackets, start with the prefix  style , followed by a dot (.) and the name of a CSS style property:  [style.style-property] .", 
            "title": "Attribute, class, and style bindings"
        }, 
        {
            "location": "/template-syntax/#event-binding-event", 
            "text": "button   ( click )= onSave () Save / button   The only way to know about a user action is to listen for certain events such as keystrokes, mouse movements, clicks, and touches. You declare your interest in user actions through Angular event binding.  For a list of events see  https://developer.mozilla.org/en-US/docs/Web/Events", 
            "title": "Event binding ((event))"
        }, 
        {
            "location": "/template-syntax/#the-safe-navigation-operator", 
            "text": "div The current movie s name is {{movie?.name}} / div   The Angular safe navigation operator ( ?. ) is a fluent and convenient way to guard against nulls in property paths. The expression bails out when it hits the first null value. The display is blank, but the app keeps rolling without errors.  It works perfectly with long property paths such as  a?.b?.c?.d .", 
            "title": "The safe navigation operator (?.)"
        }, 
        {
            "location": "/pipes/", 
            "text": "Built-in Pipes\n\n\nasync\n\n\nspan\n{{ observable_or_promise_expression | async }}\n/\nspan\n\n\n\n\n\n\nThe \nasync\n pipe subscribes to an \nObservable\n or \nPromise\n and returns the latest value it has emitted. When a new value is emitted, the \nasync\n pipe marks the component to be checked for changes. When the component gets destroyed, the \nasync\n pipe unsubscribes automatically to avoid potential memory leaks.\n\n\ndate\n\n\nspan\n{{ dateObj | date:\nmmss\n }}\n/\nspan\n\n\n\n\n\n\nFormats a date according to locale rules.\n\n\n\n\nexpression\n is a date object or a number (milliseconds since UTC epoch) or an ISO string (\nhttps://www.w3.org/TR/NOTE-datetime\n).\n\n\nformat\n indicates which date/time components to include. The format can be predefined as shown below or custom as shown in the table.\n\n\n'medium'\n: equivalent to \n'yMMMdjms'\n (e.g. \nSep 3, 2010, 12:05:08 PM\n for \nen-US\n)\n\n\n'short'\n: equivalent to \n'yMdjm'\n (e.g. \n9/3/2010, 12:05 PM\n for \nen-US\n)\n\n\n'fullDate'\n: equivalent to \n'yMMMMEEEEd'\n (e.g. \nFriday, September 3, 2010\n for \nen-US\n)\n\n\n'longDate'\n: equivalent to \n'yMMMMd'\n (e.g. \nSeptember 3, 2010\n for \nen-US\n)\n\n\n'mediumDate'\n: equivalent to \n'yMMMd'\n (e.g. \nSep 3, 2010\n for \nen-US\n)\n\n\n'shortDate'\n: equivalent to \n'yMd'\n (e.g. \n9/3/2010\n for \nen-US\n)\n\n\n'mediumTime'\n: equivalent to \n'jms'\n (e.g. \n12:05:08 PM\n for \nen-US\n)\n\n\n'shortTime'\n: equivalent to \n'jm'\n (e.g. \n12:05 PM\n for \nen-US\n)\n\n\n\n\n\n\n\n\nModifiers Table\n\n\n\n\n\n\n\n\nComponent\n\n\nSymbol\n\n\nNarrow\n\n\nShort Form\n\n\nLong Form\n\n\nNumeric\n\n\n2-digit\n\n\n\n\n\n\n\n\n\n\nera\n\n\nG\n\n\nG (A)\n\n\nGGG (AD)\n\n\nGGGG (Anno Domini)\n\n\n-\n\n\n-\n\n\n\n\n\n\nyear\n\n\ny\n\n\n-\n\n\n-\n\n\n-\n\n\ny (2015)\n\n\nyy (15)\n\n\n\n\n\n\nmonth\n\n\nM\n\n\nL (S)\n\n\nMMM (Sep)\n\n\nMMMM (September)\n\n\nM (9)\n\n\nMM (09)\n\n\n\n\n\n\nday\n\n\nd\n\n\n-\n\n\n-\n\n\n-\n\n\nd (3)\n\n\ndd (03)\n\n\n\n\n\n\nweekday\n\n\nE\n\n\nE (S)\n\n\nEEE (Sun)\n\n\nEEEE (Sunday)\n\n\n-\n\n\n-\n\n\n\n\n\n\nhour\n\n\nj\n\n\n-\n\n\n-\n\n\n-\n\n\nj (13)\n\n\njj (13)\n\n\n\n\n\n\nhour12\n\n\nh\n\n\n-\n\n\n-\n\n\n-\n\n\nh (1 PM)\n\n\nhh (01 PM)\n\n\n\n\n\n\nhour24\n\n\nH\n\n\n-\n\n\n-\n\n\n-\n\n\nH (13)\n\n\nHH (13)\n\n\n\n\n\n\nminute\n\n\nm\n\n\n-\n\n\n-\n\n\n-\n\n\nm (5)\n\n\nmm (05)\n\n\n\n\n\n\nsecond\n\n\ns\n\n\n-\n\n\n-\n\n\n-\n\n\ns (9)\n\n\nss (09)\n\n\n\n\n\n\ntimezone\n\n\nz\n\n\n-\n\n\n-\n\n\nz (Pacific Standard Time)\n\n\n-\n\n\n-\n\n\n\n\n\n\ntimezone\n\n\nZ\n\n\n-\n\n\nZ (GMT-8:00)\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\ntimezone\n\n\na\n\n\n-\n\n\na (PM)\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\n\n\ni18nPlural\n\n\nspan\n{{ expression | i18nPlural:mapping }}\n/\nspan\n\n\n\n\n\n\nMaps a value to a string that pluralizes the value according to locale rules.\n\n\n\n\nexpression\n is a number.\n\n\nmapping\n is an object that mimics the ICU format, see \nhttp://userguide.icu-project.org/formatparse/messages\n\n\n\n\n@Component\n({\n\n  \nselector\n:\n \ni18n-plural-pipe\n,\n\n  \ntemplate\n:\n \n`\ndiv\n{{ messages.length | i18nPlural: messageMapping }}\n/div\n`\n\n\n})\n\n\nexport\n \nclass\n \nI18nPluralPipeComponent\n \n{\n\n  \nmessages\n: \nany\n[]\n \n=\n \n[\nMessage 1\n];\n\n  \nmessageMapping\n:\n\n      \n{[\nk\n: \nstring\n]\n:\n \nstring\n}\n \n=\n \n{\n\n          \n=0\n:\n \nNo messages.\n,\n\n          \n=1\n:\n \nOne message.\n,\n\n          \nother\n:\n \n# messages.\n};\n\n\n}\n\n\n\n\n\n\ni18nSelect\n\n\nspan\n{{ expression | i18nSelect:mapping }}\n/\nspan\n\n\n\n\n\n\nGeneric selector that displays the string that matches the current value.\n\n\n@Component\n({\n\n    \nselector\n:\n \ni18n-select-pipe\n,\n\n    \ntemplate\n:\n \n`{{gender | i18nSelect: inviteMap}} `\n})\n\n\nexport\n \nclass\n \nI18nSelectPipeComponent\n \n{\n\n  \ngender\n: \nstring\n \n=\n \nmale\n;\n\n  \ninviteMap\n: \nany\n \n=\n \n{\n\n    \nmale\n:\n \nInvite him.\n,\n\n    \nfemale\n:\n \nInvite her.\n,\n\n    \nother\n:\n \nInvite them.\n};\n\n\n}\n\n\n\n\n\n\njson\n\n\nspan\n{{ expression | json }}\n/\nspan\n\n\n\n\n\n\nConverts value into string using JSON.stringify. Useful for debugging.\n\n\nlowercase\n\n\nspan\n{{ string | lowercase }}\n/\nspan\n\n\n\n\n\n\nTransforms text to lowercase.\n\n\ncurrency\n\n\np\nA: {{number | currency:\nUSD\n:false}}\n/\np\n\n\np\nB: {{number | currency:\nUSD\n:true:\n4.2-2\n}}\n/\np\n\n\n\n\n\n\nFormats a number as currency using locale rules.\n\n\nUse \ncurrency\n to format a number as currency.\n\n\n\n\ncurrencyCode\n is the \nISO 4217\n currency code, such as \nUSD\n for the US dollar and \nEUR\n for the euro.\n\n\nsymbolDisplay\n is a boolean indicating whether to use the currency symbol or code.\n\n\ntrue\n: use symbol (e.g. `\ndiv class=\"description\").\n\n\nfalse\n (default): use code (e.g. \nUSD\n).\n\n\n\n\n\n\ndigitInfo\n See \nDecimalPipe\n for detailed description.\n\n\n\n\nnumber\n\n\np\ne (3.1-5): {{e | number:\n3.1-5\n}}\n/\np\n\n\n\n\n\n\nFormats a number as text. Group sizing and separator and other locale-specific configurations are based on the active locale.\n\n\n\n\ndigitInfo\n is a \nstring\n which has a following format:\n\n\n{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}\n\n\nminIntegerDigits\n is the minimum number of integer digits to use. Defaults to \n1\n.\n\n\nminFractionDigits\n is the minimum number of digits after fraction. Defaults to \n0\n.\n\n\nmaxFractionDigits\n is the maximum number of digits after fraction. Defaults to \n3\n.\n\n\n\n\npercent\n\n\np\nB: {{b | percent:\n4.3-5\n}}\n/\np\n\n\n\n\n\n\nFormats a number as percentage. See DecimalPipe for detailed description.\n\n\nslice\n\n\nspan\n{{ array_or_string_expression | slice:start[:end] }}\n/\nspan\n\n\nli\n \n*\nngFor\n=\nlet i of collection | slice:1:3\n{{i}}\n/\nli\n\n\n\n\n\n\nCreates a new List or String containing a subset (slice) of the elements.\n\n\nWhere the input expression is a \nList\n or \nString\n, and:\n\n\n\n\nstart\n: The starting index of the subset to return.\n\n\na positive integer: return the item at \nstart\n index and all items after in the list or string expression.\n\n\na negative integer: return the item at \nstart\n index from the end and all items after in the list or string expression.\n\n\nif positive and greater than the size of the expression: return an empty list or string.\n\n\nif negative and greater than the size of the expression: return entire list or string.\n\n\n\n\n\n\n\n\nend\n: The ending index of the subset to return.\n\n\n\n\nomitted: return all items until the end.\n\n\nif positive: return all items before \nend\n index of the list or string.\n\n\nif negative: return all items before \nend\n index from the end of the list or string.\n\n\n\n\n\n\n\n\nAll behavior is based on the expected behavior of the JavaScript API Array.prototype.slice() and String.prototype.slice().\n\n\nuppercase\n\n\nspan\n{{ string | uppercase }}\n/\nspan\n\n\n\n\n\n\nTransforms text to uppercase.\n\n\ntitlecase\n\n\nspan\n{{ string | titlecase }}\n/\nspan\n\n\n\n\n\n\nTransforms text to titlecase.\n\n\nCustom Pipes\n\n\nimport\n \n{\n \nPipe\n,\n \nPipeTransform\n \n}\n \nfrom\n \n@angular/core\n;\n\n\n\n@Pipe\n({\nname\n:\n \nexponentialStrength\n})\n\n\nexport\n \nclass\n \nExponentialStrengthPipe\n \nimplements\n \nPipeTransform\n \n{\n\n  \ntransform\n(\nvalue\n: \nnumber\n,\n \nexponent\n: \nstring\n)\n:\n \nnumber\n \n{\n\n    \nlet\n \nexp\n \n=\n \nparseFloat\n(\nexponent\n);\n\n    \nreturn\n \nMath\n.\npow\n(\nvalue\n,\n \nisNaN\n(\nexp\n)\n \n?\n \n1\n : \nexp\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nspan\n{{ 2 |  exponentialStrength: 10}}}\n/\nspan\n\n\n\n\n\n\n\n\nA pipe is a class decorated with pipe metadata.\n\n\nThe pipe class implements the \nPipeTransform\n interface's \ntransform\n method that accepts an input value followed by optional parameters and returns the transformed value.\n\n\nThere will be one additional argument to the \ntransform\n method for each parameter passed to the pipe. Your pipe has one such parameter: the \nexponent\n.\n\n\nTo tell Angular that this is a pipe, you apply the \n@Pipe\n decorator, which you import from the core Angular library.\n\n\nThe \n@Pipe\n decorator allows you to define the pipe name that you'll use within template expressions. It must be a valid JavaScript identifier. Your pipe's name is \nexponentialStrength\n.", 
            "title": "Pipes"
        }, 
        {
            "location": "/pipes/#built-in-pipes", 
            "text": "", 
            "title": "Built-in Pipes"
        }, 
        {
            "location": "/pipes/#async", 
            "text": "span {{ observable_or_promise_expression | async }} / span   The  async  pipe subscribes to an  Observable  or  Promise  and returns the latest value it has emitted. When a new value is emitted, the  async  pipe marks the component to be checked for changes. When the component gets destroyed, the  async  pipe unsubscribes automatically to avoid potential memory leaks.", 
            "title": "async"
        }, 
        {
            "location": "/pipes/#date", 
            "text": "span {{ dateObj | date: mmss  }} / span   Formats a date according to locale rules.   expression  is a date object or a number (milliseconds since UTC epoch) or an ISO string ( https://www.w3.org/TR/NOTE-datetime ).  format  indicates which date/time components to include. The format can be predefined as shown below or custom as shown in the table.  'medium' : equivalent to  'yMMMdjms'  (e.g.  Sep 3, 2010, 12:05:08 PM  for  en-US )  'short' : equivalent to  'yMdjm'  (e.g.  9/3/2010, 12:05 PM  for  en-US )  'fullDate' : equivalent to  'yMMMMEEEEd'  (e.g.  Friday, September 3, 2010  for  en-US )  'longDate' : equivalent to  'yMMMMd'  (e.g.  September 3, 2010  for  en-US )  'mediumDate' : equivalent to  'yMMMd'  (e.g.  Sep 3, 2010  for  en-US )  'shortDate' : equivalent to  'yMd'  (e.g.  9/3/2010  for  en-US )  'mediumTime' : equivalent to  'jms'  (e.g.  12:05:08 PM  for  en-US )  'shortTime' : equivalent to  'jm'  (e.g.  12:05 PM  for  en-US )", 
            "title": "date"
        }, 
        {
            "location": "/pipes/#modifiers-table", 
            "text": "Component  Symbol  Narrow  Short Form  Long Form  Numeric  2-digit      era  G  G (A)  GGG (AD)  GGGG (Anno Domini)  -  -    year  y  -  -  -  y (2015)  yy (15)    month  M  L (S)  MMM (Sep)  MMMM (September)  M (9)  MM (09)    day  d  -  -  -  d (3)  dd (03)    weekday  E  E (S)  EEE (Sun)  EEEE (Sunday)  -  -    hour  j  -  -  -  j (13)  jj (13)    hour12  h  -  -  -  h (1 PM)  hh (01 PM)    hour24  H  -  -  -  H (13)  HH (13)    minute  m  -  -  -  m (5)  mm (05)    second  s  -  -  -  s (9)  ss (09)    timezone  z  -  -  z (Pacific Standard Time)  -  -    timezone  Z  -  Z (GMT-8:00)  -  -  -    timezone  a  -  a (PM)  -  -  -", 
            "title": "Modifiers Table"
        }, 
        {
            "location": "/pipes/#i18nplural", 
            "text": "span {{ expression | i18nPlural:mapping }} / span   Maps a value to a string that pluralizes the value according to locale rules.   expression  is a number.  mapping  is an object that mimics the ICU format, see  http://userguide.icu-project.org/formatparse/messages   @Component ({ \n   selector :   i18n-plural-pipe , \n   template :   ` div {{ messages.length | i18nPlural: messageMapping }} /div `  })  export   class   I18nPluralPipeComponent   { \n   messages :  any []   =   [ Message 1 ]; \n   messageMapping : \n       {[ k :  string ] :   string }   =   { \n           =0 :   No messages. , \n           =1 :   One message. , \n           other :   # messages. };  }", 
            "title": "i18nPlural"
        }, 
        {
            "location": "/pipes/#i18nselect", 
            "text": "span {{ expression | i18nSelect:mapping }} / span   Generic selector that displays the string that matches the current value.  @Component ({ \n     selector :   i18n-select-pipe , \n     template :   `{{gender | i18nSelect: inviteMap}} ` })  export   class   I18nSelectPipeComponent   { \n   gender :  string   =   male ; \n   inviteMap :  any   =   { \n     male :   Invite him. , \n     female :   Invite her. , \n     other :   Invite them. };  }", 
            "title": "i18nSelect"
        }, 
        {
            "location": "/pipes/#json", 
            "text": "span {{ expression | json }} / span   Converts value into string using JSON.stringify. Useful for debugging.", 
            "title": "json"
        }, 
        {
            "location": "/pipes/#lowercase", 
            "text": "span {{ string | lowercase }} / span   Transforms text to lowercase.", 
            "title": "lowercase"
        }, 
        {
            "location": "/pipes/#currency", 
            "text": "p A: {{number | currency: USD :false}} / p  p B: {{number | currency: USD :true: 4.2-2 }} / p   Formats a number as currency using locale rules.  Use  currency  to format a number as currency.   currencyCode  is the  ISO 4217  currency code, such as  USD  for the US dollar and  EUR  for the euro.  symbolDisplay  is a boolean indicating whether to use the currency symbol or code.  true : use symbol (e.g. ` div class=\"description\").  false  (default): use code (e.g.  USD ).    digitInfo  See  DecimalPipe  for detailed description.", 
            "title": "currency"
        }, 
        {
            "location": "/pipes/#number", 
            "text": "p e (3.1-5): {{e | number: 3.1-5 }} / p   Formats a number as text. Group sizing and separator and other locale-specific configurations are based on the active locale.   digitInfo  is a  string  which has a following format:  {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}  minIntegerDigits  is the minimum number of integer digits to use. Defaults to  1 .  minFractionDigits  is the minimum number of digits after fraction. Defaults to  0 .  maxFractionDigits  is the maximum number of digits after fraction. Defaults to  3 .", 
            "title": "number"
        }, 
        {
            "location": "/pipes/#percent", 
            "text": "p B: {{b | percent: 4.3-5 }} / p   Formats a number as percentage. See DecimalPipe for detailed description.", 
            "title": "percent"
        }, 
        {
            "location": "/pipes/#slice", 
            "text": "span {{ array_or_string_expression | slice:start[:end] }} / span  li   * ngFor = let i of collection | slice:1:3 {{i}} / li   Creates a new List or String containing a subset (slice) of the elements.  Where the input expression is a  List  or  String , and:   start : The starting index of the subset to return.  a positive integer: return the item at  start  index and all items after in the list or string expression.  a negative integer: return the item at  start  index from the end and all items after in the list or string expression.  if positive and greater than the size of the expression: return an empty list or string.  if negative and greater than the size of the expression: return entire list or string.     end : The ending index of the subset to return.   omitted: return all items until the end.  if positive: return all items before  end  index of the list or string.  if negative: return all items before  end  index from the end of the list or string.     All behavior is based on the expected behavior of the JavaScript API Array.prototype.slice() and String.prototype.slice().", 
            "title": "slice"
        }, 
        {
            "location": "/pipes/#uppercase", 
            "text": "span {{ string | uppercase }} / span   Transforms text to uppercase.", 
            "title": "uppercase"
        }, 
        {
            "location": "/pipes/#titlecase", 
            "text": "span {{ string | titlecase }} / span   Transforms text to titlecase.", 
            "title": "titlecase"
        }, 
        {
            "location": "/pipes/#custom-pipes", 
            "text": "import   {   Pipe ,   PipeTransform   }   from   @angular/core ;  @Pipe ({ name :   exponentialStrength })  export   class   ExponentialStrengthPipe   implements   PipeTransform   { \n   transform ( value :  number ,   exponent :  string ) :   number   { \n     let   exp   =   parseFloat ( exponent ); \n     return   Math . pow ( value ,   isNaN ( exp )   ?   1  :  exp ); \n   }  }   span {{ 2 |  exponentialStrength: 10}}} / span    A pipe is a class decorated with pipe metadata.  The pipe class implements the  PipeTransform  interface's  transform  method that accepts an input value followed by optional parameters and returns the transformed value.  There will be one additional argument to the  transform  method for each parameter passed to the pipe. Your pipe has one such parameter: the  exponent .  To tell Angular that this is a pipe, you apply the  @Pipe  decorator, which you import from the core Angular library.  The  @Pipe  decorator allows you to define the pipe name that you'll use within template expressions. It must be a valid JavaScript identifier. Your pipe's name is  exponentialStrength .", 
            "title": "Custom Pipes"
        }, 
        {
            "location": "/interfaces/", 
            "text": "An interface is a specification identifying a related set of properties and methods. A class commits to supporting the specification by implementing the interface and then the interface can be used as a data type.\n\n\nexport\n \ninterface\n \nICar\n \n{\n\n  \ncarId\n: \nnumber\n;\n\n  \ncarName\n: \nstring\n;\n\n  \ncarModel\n: \nstring\n;\n\n  \nremainingMiles\n(\ngas\n: \nnumber\n,\n \nspeed\n:\nnumber\n)\n:\n \nnumber\n;\n\n\n}\n\n\n\n\n\n\nimport\n \n{\n \nICar\n \n}\n \nfrom\n \n./car\n;\n\n\n\nexport\n \nclass\n \nCarListComponent\n \n{\n\n  \ncars\n: \nICar\n[]\n \n=\n \n[...];\n\n\n}", 
            "title": "Interfaces"
        }, 
        {
            "location": "/lifecycle-hooks/", 
            "text": "After creating a component/directive by calling its constructor, Angular calls the lifecycle hook methods in the following sequence at specific moments:\n\n\nngOnChanges()\n\n\nRespond when Angular (re)sets data-bound input properties. The method receives a \nSimpleChanges\n object of current and previous property values.\n\n\nCalled before \nngOnInit()\n and whenever one or more data-bound input properties change.\n\n\nngOnInit()\n\n\nInitialize the directive/component after Angular first displays the data-bound properties and sets the directive/component's input properties.\n\n\nCalled \nonce\n, after the \nfirst\n \nngOnChanges()\n.\n\n\nngDoCheck()\n\n\nDetect and act upon changes that Angular can't or won't detect on its own. Called during every change detection run, immediately after \nngOnChanges()\n and \nngOnInit()\n.\n\n\nngAfterContentInit()\n\n\nRespond after Angular projects external content into the component's view.\n\n\nCalled \nonce\n after the first \nngDoCheck()\n.\n\n\nA component-only hook\n.\n\n\nngAfterContentChecked()\n\n\nRespond after Angular checks the content projected into the component.\n\n\nCalled after the \nngAfterContentInit()\n and every subsequent \nngDoCheck()\n.\n\n\nA component-only hook\n.\n\n\nngAfterViewInit()\n\n\nRespond after Angular initializes the component's views and child views.\n\n\nCalled \nonce\n after the first \nngAfterContentChecked()\n.\n\n\nA component-only hook\n.\n\n\nngAfterViewChecked()\n\n\nRespond after Angular checks the component's views and child views.\n\n\nCalled after the \nngAfterViewInit\n and every subsequent \nngAfterContentChecked()\n.\n\n\nA component-only hook\n.\n\n\nngOnDestroy()\n\n\nCleanup just before Angular destroys the directive/component. Unsubscribe Observables and detach event handlers to avoid memory leaks.\n\n\nCalled \njust before\n Angular destroys the directive/component.", 
            "title": "Lifecycle Hooks"
        }, 
        {
            "location": "/lifecycle-hooks/#ngonchanges", 
            "text": "Respond when Angular (re)sets data-bound input properties. The method receives a  SimpleChanges  object of current and previous property values.  Called before  ngOnInit()  and whenever one or more data-bound input properties change.", 
            "title": "ngOnChanges()"
        }, 
        {
            "location": "/lifecycle-hooks/#ngoninit", 
            "text": "Initialize the directive/component after Angular first displays the data-bound properties and sets the directive/component's input properties.  Called  once , after the  first   ngOnChanges() .", 
            "title": "ngOnInit()"
        }, 
        {
            "location": "/lifecycle-hooks/#ngdocheck", 
            "text": "Detect and act upon changes that Angular can't or won't detect on its own. Called during every change detection run, immediately after  ngOnChanges()  and  ngOnInit() .", 
            "title": "ngDoCheck()"
        }, 
        {
            "location": "/lifecycle-hooks/#ngaftercontentinit", 
            "text": "Respond after Angular projects external content into the component's view.  Called  once  after the first  ngDoCheck() .  A component-only hook .", 
            "title": "ngAfterContentInit()"
        }, 
        {
            "location": "/lifecycle-hooks/#ngaftercontentchecked", 
            "text": "Respond after Angular checks the content projected into the component.  Called after the  ngAfterContentInit()  and every subsequent  ngDoCheck() .  A component-only hook .", 
            "title": "ngAfterContentChecked()"
        }, 
        {
            "location": "/lifecycle-hooks/#ngafterviewinit", 
            "text": "Respond after Angular initializes the component's views and child views.  Called  once  after the first  ngAfterContentChecked() .  A component-only hook .", 
            "title": "ngAfterViewInit()"
        }, 
        {
            "location": "/lifecycle-hooks/#ngafterviewchecked", 
            "text": "Respond after Angular checks the component's views and child views.  Called after the  ngAfterViewInit  and every subsequent  ngAfterContentChecked() .  A component-only hook .", 
            "title": "ngAfterViewChecked()"
        }, 
        {
            "location": "/lifecycle-hooks/#ngondestroy", 
            "text": "Cleanup just before Angular destroys the directive/component. Unsubscribe Observables and detach event handlers to avoid memory leaks.  Called  just before  Angular destroys the directive/component.", 
            "title": "ngOnDestroy()"
        }, 
        {
            "location": "/class-field-decorators/", 
            "text": "Class field decorators for directives/components\n\n\n@Input()\n myProperty;\n\n\nDeclares an input property that you can update via property binding (example: \nmy-cmp [myProperty]=\"someExpression\"\n).\n\n\nAlias can be used: \n@Input(alias_string)\n.\n\n\nExample\n\n\nIn this example, the child component \nRatingComponent\n is nested in the parent component \nMoviesComponent\n. The \n@Input()\n decorator is used on the \nstars\n property of the child component. This allows the component to receive values from the parent component using property binding.\n\n\nrating.component.ts\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nrating\n,\n\n  \ntemplateUrl\n:\n \nrating.component.ts\n\n\n})\n\n\nexport\n \nclass\n \nRatingComponent\n \n{\n\n  \n@Input\n()\n \nstars\n: \nnumber\n;\n\n\n}\n\n\n\n\n\n\nmovies-list.component.ts\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nmovies\n,\n\n  \ntemplateUrl\n:\n \nmovies-list.component.ts\n\n\n})\n\n\nexport\n \nclass\n \nMoviesComponent\n \n{\n\n  \nmovies\n: \nIMovie\n[];\n\n\n}\n\n\n\n\n\n\nmovies-list.component.html\n\n\n\ndiv\n \n*\nngFor\n=\nlet movie of movies\n\n  {{ movie.name }} \nrating\n \n[\nstars\n]=\nmovie\n.\nrating\n/\nrating\n\n\n/\ndiv\n\n\n\n\n\n\n@Output()\n\u00a0myEvent\u00a0=\u00a0new\u00a0EventEmitter();\n\n\nDeclares an output property that fires events that you can subscribe to with an event binding (example: \nmy-cmp (myEvent)=\"doSomething()\"\n).\n\n\nAlias can be used: \n@Output(alias_string)\n.\n\n\nExample\n\n\nThe child component exposes an \nEventEmitter\n property with which it \nemits\n events when something happens. The parent binds to that event property and reacts to those events.\n\n\nThe events payload can be accessed by the parameter \n$event\n on the components output event handler.\n\n\nThe generic argument (\npayload-type\n) is used to define the event payload type.\n\n\nrating.component.ts\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nrating\n,\n\n  \ntemplateUrl\n:\n \nrating.component.ts\n\n\n})\n\n\nexport\n \nclass\n \nRatingComponent\n \n{\n\n  \n@Input\n()\n \nstars\n: \nnumber\n;\n\n  \n@Output\n()\n \nnotify\n: \nEventEmitter\nstring\n \n=\n \nnew\n \nEventEmitter\nstring\n();\n\n  \nonClick() {\n\n    \nthis\n.\nnotify\n.\nemit\n(\nStar was clicked!\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nrating.component.html\n\n\n\ndiv\n \n(\nclick\n)=\nonClick\n()\n\n  \u2605\u2605\u2605\u2605\u2729\n\n/\ndiv\n\n\n\n\n\n\nmovies-list.component.ts\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nmovies\n,\n\n  \ntemplateUrl\n:\n \nmovies-list.component.ts\n\n\n})\n\n\nexport\n \nclass\n \nMoviesComponent\n \n{\n\n  \nmovies\n: \nIMovie\n[];\n\n  \nonNotify\n(\nmessage\n: \nstring\n)\n:\n \n{\n\n    \n// message = \nStar was clicked!\n\n    \nconsole\n.\nlog\n(\n`Message received: \n${\nmessage\n}\n`\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nmovies-list.component.html\n\n\n\ndiv\n \n*\nngFor\n=\nlet movie of movies\n\n  {{ movie.name }}\n  \nrating\n \n[\nstars\n]=\nmovie\n.\nrating\n \n(\nnotify\n)=\nonNotify\n($\nevent\n)\n/\nrating\n\n\n/\ndiv\n\n\n\n\n\n\n@HostBinding('class.valid')\u00a0isValid;\n\n\nBinds a host element property (here, the CSS class \nvalid\n) to a directive/component property (\nisValid\n).\n\n\n@HostListener('click',\u00a0['$event'])\u00a0onClick(e)\u00a0{...}\n\n\nSubscribes to a host element event (\nclick\n) with a directive/component method (\nonClick\n), optionally passing an argument (\n$event\n).\n\n\n@ContentChild(myPredicate)\u00a0myChildComponent;\n\n\nBinds the first result of the component content query (\nmyPredicate\n) to a property (\nmyChildComponent\n) of the class.\n\n\n@ContentChildren(myPredicate)\u00a0myChildComponents;\n\n\nBinds the results of the component content query (\nmyPredicate\n) to a property (\nmyChildComponents\n) of the class.\n\n\n@ViewChild(myPredicate)\u00a0myChildComponent;\n\n\nBinds the first result of the component view query (\nmyPredicate\n) to a property (\nmyChildComponent\n) of the class. Not available for directives.\n\n\n@ViewChildren(myPredicate)\u00a0myChildComponents;\n\n\nBinds the results of the component view query (\nmyPredicate\n) to a property (\nmyChildComponents\n) of the class. Not available for directives.", 
            "title": "Class field decorators"
        }, 
        {
            "location": "/class-field-decorators/#class-field-decorators-for-directivescomponents", 
            "text": "", 
            "title": "Class field decorators for directives/components"
        }, 
        {
            "location": "/class-field-decorators/#input-myproperty", 
            "text": "Declares an input property that you can update via property binding (example:  my-cmp [myProperty]=\"someExpression\" ).  Alias can be used:  @Input(alias_string) .", 
            "title": "@Input() myProperty;"
        }, 
        {
            "location": "/class-field-decorators/#example", 
            "text": "In this example, the child component  RatingComponent  is nested in the parent component  MoviesComponent . The  @Input()  decorator is used on the  stars  property of the child component. This allows the component to receive values from the parent component using property binding.  rating.component.ts  @Component ({ \n   selector :   rating , \n   templateUrl :   rating.component.ts  })  export   class   RatingComponent   { \n   @Input ()   stars :  number ;  }   movies-list.component.ts  @Component ({ \n   selector :   movies , \n   templateUrl :   movies-list.component.ts  })  export   class   MoviesComponent   { \n   movies :  IMovie [];  }   movies-list.component.html  div   * ngFor = let movie of movies \n  {{ movie.name }}  rating   [ stars ]= movie . rating / rating  / div", 
            "title": "Example"
        }, 
        {
            "location": "/class-field-decorators/#output-myevent-new-eventemitter", 
            "text": "Declares an output property that fires events that you can subscribe to with an event binding (example:  my-cmp (myEvent)=\"doSomething()\" ).  Alias can be used:  @Output(alias_string) .", 
            "title": "@Output()\u00a0myEvent\u00a0=\u00a0new\u00a0EventEmitter();"
        }, 
        {
            "location": "/class-field-decorators/#example_1", 
            "text": "The child component exposes an  EventEmitter  property with which it  emits  events when something happens. The parent binds to that event property and reacts to those events.  The events payload can be accessed by the parameter  $event  on the components output event handler.  The generic argument ( payload-type ) is used to define the event payload type.  rating.component.ts  @Component ({ \n   selector :   rating , \n   templateUrl :   rating.component.ts  })  export   class   RatingComponent   { \n   @Input ()   stars :  number ; \n   @Output ()   notify :  EventEmitter string   =   new   EventEmitter string (); \n   onClick() { \n     this . notify . emit ( Star was clicked! ); \n   }  }   rating.component.html  div   ( click )= onClick () \n  \u2605\u2605\u2605\u2605\u2729 / div   movies-list.component.ts  @Component ({ \n   selector :   movies , \n   templateUrl :   movies-list.component.ts  })  export   class   MoviesComponent   { \n   movies :  IMovie []; \n   onNotify ( message :  string ) :   { \n     // message =  Star was clicked! \n     console . log ( `Message received:  ${ message } ` ); \n   }  }   movies-list.component.html  div   * ngFor = let movie of movies \n  {{ movie.name }}\n   rating   [ stars ]= movie . rating   ( notify )= onNotify ($ event ) / rating  / div", 
            "title": "Example"
        }, 
        {
            "location": "/class-field-decorators/#hostbindingclassvalid-isvalid", 
            "text": "Binds a host element property (here, the CSS class  valid ) to a directive/component property ( isValid ).", 
            "title": "@HostBinding('class.valid')\u00a0isValid;"
        }, 
        {
            "location": "/class-field-decorators/#hostlistenerclick-event-onclicke", 
            "text": "Subscribes to a host element event ( click ) with a directive/component method ( onClick ), optionally passing an argument ( $event ).", 
            "title": "@HostListener('click',\u00a0['$event'])\u00a0onClick(e)\u00a0{...}"
        }, 
        {
            "location": "/class-field-decorators/#contentchildmypredicate-mychildcomponent", 
            "text": "Binds the first result of the component content query ( myPredicate ) to a property ( myChildComponent ) of the class.", 
            "title": "@ContentChild(myPredicate)\u00a0myChildComponent;"
        }, 
        {
            "location": "/class-field-decorators/#contentchildrenmypredicate-mychildcomponents", 
            "text": "Binds the results of the component content query ( myPredicate ) to a property ( myChildComponents ) of the class.", 
            "title": "@ContentChildren(myPredicate)\u00a0myChildComponents;"
        }, 
        {
            "location": "/class-field-decorators/#viewchildmypredicate-mychildcomponent", 
            "text": "Binds the first result of the component view query ( myPredicate ) to a property ( myChildComponent ) of the class. Not available for directives.", 
            "title": "@ViewChild(myPredicate)\u00a0myChildComponent;"
        }, 
        {
            "location": "/class-field-decorators/#viewchildrenmypredicate-mychildcomponents", 
            "text": "Binds the results of the component view query ( myPredicate ) to a property ( myChildComponents ) of the class. Not available for directives.", 
            "title": "@ViewChildren(myPredicate)\u00a0myChildComponents;"
        }, 
        {
            "location": "/communicating-btw-components/", 
            "text": "@Input() / @Output()\n\n\nSee \nClass field decorators\n\n\nUsing a Template \n#variable\n\n\nThis is an easy and straight forward way to communicate between components.\n\n\nIn this example \nRatingComponent\n is a child of \nMoviesListComponent\n.\n\n\nNote how the local variable \n#ratingVar\n points to \nRatingComponent\n. This variable is used by the parent to access the properties and methods of the child component.\n\n\nmovies-list.component.html\n\n\n\ndiv\n \n*\nngFor\n=\nlet movie of movies\n\n  {{ movie.name }}\n  \nrating\n \n#\nratingVar\n/\nrating\n\n  \np\nStars: {{ ratingVar.star }}\n/\np\n\n  \nbutton\n \n(\nclick\n)=\nratingVar\n.\naddStar\n()\n/\nbutton\n\n\n/\ndiv\n\n\n\n\n\n\nrating.component.ts\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nrating\n,\n\n  \ntemplateUrl\n:\n \nrating.component.ts\n\n\n})\n\n\nexport\n \nclass\n \nRatingComponent\n \n{\n\n  \n@Input\n()\n \nstars\n: \nnumber\n;\n\n  \nstars\n: \nnumber\n \n=\n \n3\n;\n\n  \naddStar() {\n\n    \nconsole\n.\nlog\n(\nStar added\n);\n\n  \n}\n\n\n}", 
            "title": "Communicating Between Components"
        }, 
        {
            "location": "/communicating-btw-components/#input-output", 
            "text": "See  Class field decorators", 
            "title": "@Input() / @Output()"
        }, 
        {
            "location": "/communicating-btw-components/#using-a-template-variable", 
            "text": "This is an easy and straight forward way to communicate between components.  In this example  RatingComponent  is a child of  MoviesListComponent .  Note how the local variable  #ratingVar  points to  RatingComponent . This variable is used by the parent to access the properties and methods of the child component.  movies-list.component.html  div   * ngFor = let movie of movies \n  {{ movie.name }}\n   rating   # ratingVar / rating \n   p Stars: {{ ratingVar.star }} / p \n   button   ( click )= ratingVar . addStar () / button  / div   rating.component.ts  @Component ({ \n   selector :   rating , \n   templateUrl :   rating.component.ts  })  export   class   RatingComponent   { \n   @Input ()   stars :  number ; \n   stars :  number   =   3 ; \n   addStar() { \n     console . log ( Star added ); \n   }  }", 
            "title": "Using a Template #variable"
        }, 
        {
            "location": "/services/", 
            "text": "import\n \n{\n \nInjectable\n \n}\n \nfrom\n \n@angular/core\n;\n\n\n\n@Injectable\n()\n\n\nexport\n \nclass\n \nMovieService\n \n{\n\n  \ngetMovies\n()\n:\n \nIMovie\n[]\n \n{\n\n    \n// movies array\n\n  \n};\n\n\n}\n\n\n\n\n\n\nA Service is a class with a focus purpose. Used for features that:\n\n\n\n\nAre independent from any particular component\n\n\nProvide shared data or logic across components\n\n\nEncapsulate external interactions\nThe service should be imported and added to the \nproviders\n property of a @Component or in a @ngModule. The service will be available for all childs.\n\n\n\n\nImportant:\n If a service is registered twice in 2 different components, we will no longer have a singleton and we will end up with 2 instances of the Service.\n\n\nimport\n \n{\n \nMovieService\n \n}\n \nfrom\n \n./movie.service.ts\n;\n\n\n\n@Component\n({\n\n  \nproviders\n:\n \n[\n \nMovieService\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nRootComponent\n \n{\n\n  \n// properties and methods\n\n\n}\n\n\n\n\n\n\nDependecy Injection\n is a coding pattern in which a class receives the instances of objects it needs (called dependencies) from an external source rather than creating them itself.\n\n\nThe Service should be injected in the constructor.\n\n\nimport\n \n{\n \nMovieService\n \n}\n \nfrom\n \n./movie.service.ts\n;\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nmovies\n,\n\n  \ntemplateUrl\n:\n \nmovies-list.component.html\n\n\n})\n\n\nexport\n \nclass\n \nMoviesComponent\n \nimplements\n \nonInit\n \n{\n\n  \n// ...\n\n  \nconstructor\n \n(\nprivate\n \n_movieService\n: \nMovieService\n)\n \n{\n\n  \n}\n\n  \nngOnInit\n()\n:\n \nvoid\n \n{\n\n    \nthis\n.\nmovies\n \n=\n \nthis\n.\n_movieService\n.\ngetMovies\n();\n\n  \n}\n\n\n}", 
            "title": "Services and Dependency Injection"
        }, 
        {
            "location": "/http/", 
            "text": "movie.service.ts\n\n\n\nimport\n \n{\n \nHttp\n,\n \nResponse\n \n}\n \nfrom\n \n@angular/http\n;\n\n\nimport\n \n{\n \nObservable\n \n}\n \nfrom\n \nrxjs/Observable\n;\n\n\nimport\n \nrxjs/add/operator/map\n;\n\n\n\n@Injectable\n()\n\n\nexport\n \nclass\n \nMovieService\n \n{\n\n  \nprivate\n \n_movieUrl\n \n=\n \nwww.myWebService.com/api/products\n;\n\n\n  \nconstructor\n(\nprivate\n \n_http\n: \nHttp\n)\n \n{\n \n}\n\n\n  \ngetMovies\n()\n:\n \nObservable\nIMovie\n[]\n \n{\n\n    \nreturn\n \nthis\n.\n_http\n.\nget\n(\nthis\n.\n_movieUrl\n)\n\n      \n.\nmap\n((\nresponse\n: \nResponse\n)\n \n=\n \nIMovie\n[]\nresponse\n.\njson\n())\n\n      \n.\ndo\n(\ndata\n \n=\n \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\ndata\n)))\n\n      \n.\ncatch\n(\nthis\n.\nhandleError\n);\n\n  \n}\n\n\n  \nprivate\n \nhandleError\n(\nerror\n: \nResponse\n)\n \n{\n\n    \nconsole\n.\nerror\n(\nerror\n);\n\n    \nreturn\n \nObservable\n.\nthrow\n(\nerror\n.\njson\n().\nerror\n \n||\n \nServer error\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nmovies-list.component.ts\n\n\n\nimport\n \n{\n \nMovieService\n \n}\n \nfrom\n \n./movie.service.ts\n;\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nmovies\n,\n\n  \ntemplateUrl\n:\n \nmovies-list.component.html\n\n\n})\n\n\nexport\n \nclass\n \nMoviesComponent\n \nimplements\n \nonInit\n \n{\n\n  \nmovies\n: \nIMovie\n[];\n\n  \nerrorMessage\n: \nstring\n;\n\n\n  \nconstructor\n \n(\nprivate\n \n_movieService\n: \nMovieService\n)\n \n{\n\n  \n}\n\n  \nngOnInit\n()\n:\n \nvoid\n \n{\n\n    \nthis\n.\n_movieService\n.\ngetMovies\n()\n\n      \n.\nsubscribe\n(\nmovies\n \n=\n \nthis\n.\nmovies\n \n=\n \nmovies\n,\n\n                \nerror\n \n=\n \nthis\n.\nerrorMessage\n \n=\n \nany\nerror\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nPerforms http requests using \nXMLHttpRequest\n as the default backend.\n\n\nHttp\n is available as an injectable class, with methods to perform http requests. Calling \nrequest\n returns an \nObservable\n which will emit a single \nResponse\n when a response is received.\n\n\n\n\nHttpModule\n should be added to the \nimports\n array of one of the \n@ngModule", 
            "title": "Getting Data With HTTP"
        }, 
        {
            "location": "/routing/", 
            "text": "Routing \n Navigation Basics\n\n\nsrc/index.html\n\n\n\nbase\n \nhref\n=\n/\n\n\n\n\n\n\nMost routing applications should add a \nbase\n element to the \nindex.html\n as the first child in the \nhead\n tag to tell the router how to compose navigation URLs.\n\n\napp.module.ts\n\n\n\nimport\n \n{\n \nRouterModule\n,\n \nRoutes\n \n}\n \nfrom\n \n@angular/router\n;\n\n\nimport\n \n{\n \nappRoutes\n \n}\n \nfrom\n \n./routes\n;\n\n\n\n@NgModule\n({\n\n  \nimports\n:\n \n[\n\n    \n...\n\n    \nRouterModule\n.\nforRoot\n(\nappRoutes\n,\n \n{\n \nenableTracing\n: \ntrue\n \n})\n\n  \n]\n\n\n})\n\n\nexport\n \nclass\n \nAppModule\n \n{\n \n}\n\n\n\n\n\n\nroutes.ts\n\n\n\n...\n\n\nimport\n \n{\n \nRoutes\n \n}\n \nfrom\n \n@angular/router\n;\n\n\n\nexport\n \nconst\n \nappRoutes\n: \nRoutes\n \n=\n \n[\n\n  \n{\n \npath\n:\n \nmovies\n,\n \ncomponent\n: \nMovieListComponent\n \n},\n\n  \n{\n \npath\n:\n \nmovie/:id\n,\n \ncomponent\n: \nMovieDetailComponent\n \n},\n\n  \n{\n \npath\n:\n \nwelcome\n,\n \ncomponent\n: \nWelcomeComponent\n \n},\n\n  \n{\n \npath\n:\n \n,\n \nredirectTo\n:\n \nwelcome\n \npathMatch\n:\n \nfull\n \n},\n\n  \n{\n \npath\n:\n \n**\n,\n \ncomponent\n: \nPageNotFoundComponent\n \n},\n\n\n];\n\n\n\n\n\n\nThe \nappRoutes\n array of \nroutes\n describes how to navigate. Pass it to the \nRouterModule.forRoot\n method in the module \nimports\n to configure the router.\n\n\nEach \nRoute\n maps a URL \npath\n to a component. There are \nno leading slashes\n in the \npath\n. The router parses and builds the final URL for you, allowing you to use both relative and absolute paths when navigating between application views.\n\n\nThe \n:id\n in the second route is a token for a route parameter. In a URL such as \n/movie/42\n, \"42\" is the value of the \nid\n parameter. The corresponding \nMovieDetailComponent\n will use that value to find and present the movie whose \nid\n is 42. You'll learn more about route parameters later in this guide.\n\n\nThe \ndata\n property in the third route is a place to store arbitrary data associated with this specific route. The data property is accessible within each activated route. Use it to store items such as page titles, breadcrumb text, and other read-only, \nstatic\n data. You'll use the resolve guard to retrieve \ndynamic\n data later in the guide.\n\n\nThe \nempty path\n in the fourth route represents the default path for the application, the place to go when the path in the URL is empty, as it typically is at the start. This default route redirects to the route for the \n/movies\n URL and, therefore, will display the \nMoviesListComponent\n.\n\n\nThe \n**\n path in the last route is a \nwildcard\n. The router will select this route if the requested URL doesn't match any paths for routes defined earlier in the configuration. This is useful for displaying a \"404 - Not Found\" page or redirecting to another route.\n\n\nThe order of the routes in the configuration matters\n and this is by design. The router uses a \nfirst-match wins\n strategy when matching routes, so more specific routes should be placed above less specific routes. In the configuration above, routes with a static path are listed first, followed by an empty path route, that matches the default route. The wildcard route comes last because it matches \nevery URL\n and should be selected \nonly\n if no other routes are matched first.\n\n\nIf you need to see what events are happening during the navigation lifecycle, there is the \nenableTracing\n option as part of the router's default configuration. This outputs each router event that took place during each navigation lifecycle to the browser console. This should only be used for \ndebugging\n purposes. You set the \nenableTracing: true\n option in the object passed as the second argument to the \nRouterModule.forRoot()\n method.\n\n\nRouter outlet\n\n\nsrc/app/app.component.html\n\n\n\nh1\nAngular Router\n/\nh1\n\n\nrouter-outlet\n/\nrouter-outlet\n\n\n\n\n\n\nrouter-outlet\n acts as a placeholder that Angular dynamically fills based on the current router state.\n\n\nRouter\nLinks\n\n\nsrc/app/app.component.html\n\n\n\nh1\nAngular Router\n/\nh1\n\n\nnav\n\n  \na\n \nrouterLink\n=\n/movies\n \nrouterLinkActive\n=\nactive\nMovies\n/\na\n\n  \na\n\n    \n[\nrouterLink\n]=\n[\n/\nmovie\n,\n \nmovie\n.\nid\n]\n\n    \nrouterLinkActive\n=\nactive\n\n    \n[\nrouterLinkActiveOptions\n]={\nexact:true\n}\n \n{{ movie.name }}\n/\na\n\n\n/\nnav\n\n\nrouter-outlet\n/\nrouter-outlet\n\n\n\n\n\n\nThe \nRouterLink\n directives on the anchor tags give the router control over those elements. The navigation paths are fixed, so you can assign a string to the \nrouterLink\n (a \"one-time\" binding).\n\n\nHad the navigation path been more dynamic, you could have bound to a template expression that returned an array of route link parameters (the \nlink parameters array\n). The router resolves that array into a complete URL.\n\n\nThe \nRouterLinkActive\n directive on each anchor tag helps visually distinguish the anchor for the currently selected \"active\" route. The router adds the \nactive\n CSS class to the element when the associated \nRouterLink\n becomes active. You can add this directive to the anchor or to its parent element.\n\n\nReading Parameters: \nsnapshot\n\n\nmovie.component.ts\n\n\n\nimport\n \n{\n \nActivatedRoute\n \n}\n \nfrom\n \n@angular/router\n;\n\n\n...\n\n\nexport\n \nclass\n \nMovieComponent\n \nimplements\n \nOnInit\n \n{\n\n  \nconstructor\n(\nprivate\n \n_route\n: \nActivatedRoute\n)\n \n{\n \n}\n\n\n  \nngOnInit\n()\n:\n \nvoid\n \n{\n\n    \nlet\n \nid\n \n=\n \n+\nthis\n.\n_route\n.\nsnapshot\n.\nparams\n[\nid\n];\n\n  \n}\n\n\n}\n\n\n\n\n\n\nWhen you know for certain that an instance of a \nComponent\n will \nnever, never, ever\n be re-used, you can simplify the code with the \nsnapshot\n.\n\n\nThe \nroute.snapshot\n provides the initial value of the route parameter map. You can access the parameters directly without subscribing or adding observable operators. It's much simpler to write and read:\n\n\nRemember:\n you only get the \ninitial\n value of the parameter map with this technique. Stick with the observable \nparamMap\n approach if there's even a chance that the parameter will change without leaving the page.\n\n\nRouting programmatically\n\n\nmovie.component.ts\n\n\n\nimport\n \n{\n \nRouter\n \n}\n \nfrom\n \n@angular/router\n;\n\n  \n...\n\n\nexport\n \nclass\n \nMovieComponent\n \n{\n\n  \nconstructor\n(\nprivate\n \n_router\n: \nRouter\n)\n \n{\n \n}\n\n\n  \nonBack\n()\n:\n \nvoid\n \n{\n\n    \nthis\n.\n_router\n.\nnavigate\n([\nmovies\n]);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nGuards\n\n\nYou can add \nguards\n to the route configuration to handle scenarios such as:\n\n\n\n\nPerhaps the user is not authorized to navigate to the target component.\n\n\nMaybe the user must login (\nauthenticate\n) first.\n\n\nMaybe you should fetch some data before you display the target component.\n\n\nYou might want to save pending changes before leaving a component.\n\n\nYou might ask the user if it's OK to discard pending changes rather than save them.\n\n\n\n\nA guard's return value controls the router's behavior:\n\n\n\n\nIf it returns \ntrue\n, the navigation process continues.\n\n\nIf it returns \nfalse\n, the navigation process stops and the user stays put.\n\n\n\n\nThe guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.\n\n\nThe router supports multiple guard interfaces:\n\n\n\n\n\n\nCanActivate\n to mediate navigation \nto\n a route.\n\n\n\n\n\n\nCanActivateChild\n to mediate navigation \nto\n a child route.\n\n\n\n\n\n\nCanDeactivate\n to mediate navigation \naway\n from the current route.\n\n\n\n\n\n\nResolve\n to perform route data retrieval \nbefore\n route activation.\n\n\n\n\n\n\nCanLoad\n to mediate navigation \nto\n a feature module loaded \nasynchronously\n.\n\n\n\n\n\n\nFor creating Route Guards, we can use a Service or a Function. On the following examples, a \nCanActivate\n Service is used to check if the id of a movie exists. A \nCanDeactivate\n function is used to prevent the user navigating away from the new movies form if the form is dirty.\n\n\nroutes.ts\n\n\n\n...\n\n\nimport\n \n{\n \nMovieGuard\n \n}\n \nfrom\n \n./movies/movie-guard.service.ts\n;\n\n\nimport\n \n{\n \ncheckDirtyState\n \n}\n \nfrom\n \n./movies/chech-dirty.ts\n;\n\n\n\nexport\n \nconst\n \nappRoutes\n: \nRoutes\n \n=\n \n[\n\n  \n{\n \npath\n:\n\n    \nmovie/new\n,\n\n    \ncomponent\n: \nMovieListComponent\n,\n\n    \ncanDeactivate\n:\n \n[\ncanDeactivateCreateMovieGuard\n]\n\n  \n},\n\n  \n{\n \npath\n:\n \nmovies\n,\n \ncomponent\n: \nMovieListComponent\n \n},\n\n  \n{\n \npath\n:\n\n    \nmovie/:id\n,\n\n    \ncomponent\n: \nMovieDetailComponent\n,\n\n    \ncanActivate\n:\n \n[\n \nMovieGuard\n \n]\n \n},\n\n  \n{\n \npath\n:\n \n404\n,\n \ncomponent\n: \nError404Component\n \n},\n\n  \n{\n \npath\n:\n \n,\n \nredirectTo\n:\n \nwelcome\n \npathMatch\n:\n \nfull\n \n},\n\n  \n{\n \npath\n:\n \n**\n,\n \nredirectTo\n:\n \n404\n \n},\n\n\n];\n\n\n\n\n\n\nThe \nMovieGuard\n Service and the \ncanDeactivateCreateMovieGuard\n function should be added as providers.\n\n\napp.module.ts\n\n\n\nimport\n \n{\n \nMovieGuard\n \n}\n \nfrom\n \n./movies/movie-guard.service.ts\n;\n\n\n\n@NgModule\n({\n\n  \n...\n\n  \nproviders\n:\n \n[\n\n    \n...\n\n    \nMovieGuard\n,\n\n    \n{\n\n      \nprovide\n:\n \ncanDeactivateCreateMovieGuard\n,\n\n      \nuseValue\n: \ncheckDirtyState\n\n    \n}\n\n  \n]\n\n\n})\n\n\nexport\n \nclass\n \nAppModule\n \n{\n \n}\n\n\n\n\n\n\nCanActivate\n\n\nService used as the CanActivate Guard.\n\n\nmovie-guard.service.ts\n\n\n\nimport\n \n{\n \nActivatedRouteSnapshot\n,\n \nCanActivate\n,\n \nRouter\n \n}\n \nfrom\n \n@angular/router\n;\n\n\nimport\n \n{\n \nInjectable\n \n}\n \nfrom\n \n@angular/core\n;\n\n\nimport\n \n{\n \nMovieService\n \n}\n \nfrom\n \n../shared.movie.service\n;\n\n\n\n@Injectable\n()\n\n\nexport\n \nclass\n \nMovieGuard\n \nimplements\n \nCanActivate\n \n{\n\n  \nconstructor\n \n(\n\n    \nprivate\n \n_movieService\n:\nMovieService\n,\n\n    \nprivate\n \n_router\n:\nRouter\n\n    \n)\n \n{}\n\n\n  \ncanActivate\n(\nroute\n:\nActivatedRouteSnapshot\n)\n \n{\n\n    \nconst\n \nmovieExists\n \n=\n \n!!\nthis\n.\n_movieService\n.\ngetMovie\n(\n+\nroute\n.\nparams\n[\nid\n]);\n\n\n    \nif\n \n(\n!\nmovieExists\n)\n \n{\n\n      \nthis\n.\n_router\n.\nnavigate\n([\n404\n]);\n\n    \n}\n\n    \nreturn\n \nmovieExists\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\nCanDeactivate\n\n\nFunction used as the CanDeactivate Guard.\n\n\nchech-dirty.ts\n\n\n\nexport\n \nfunction\n \ncheckDirtyState\n(\ncomponent\n:\nCreateMovieComponent\n)\n \n{\n\n  \nif\n \n(\ncomponent\n.\nisDirty\n)\n \n{\n\n    \nreturn\n \nwindow\n.\nconfirm\n(\nReally want to cancel?\n);\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\ncreate-movie.component.ts\n\n\n\n@Component\n({\n\n  \nselector\n:\n \ncreate-movie\n,\n\n  \ntemplate\n:\n \n`...`\n\n\n})\n\n\nexport\n \nclass\n \nCreateMovieComponent\n \n{\n\n  \nisDirty\n: \nboolean\n \n=\n \ntrue\n;\n\n\n  \nconstructor\n \n(\nprivate\n \n_router\n: \nRouter\n)\n \n{}\n\n\n  \ncancel() {\n\n    \nthis\n.\n_router\n.\nnavigate\n([\n/movies\n]);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nResolve\n\n\nIf you were using a real world API, there might be some delay before the data to display is returned from the server. You don't want to display a blank component while waiting for the data.\n\n\nIt's preferable to pre-fetch data from the server so it's ready the moment the route is activated. This also allows you to handle errors before routing to the component. There's no point in navigating to a Movie detail for an \nid\n that doesn't have a record. It'd be better to send the user back to the \nMovies List\n that shows only valid Movies.\n\n\nIn summary, you want to delay rendering the routed component until all necessary data have been fetched.\n\n\nYou need a \nresolver\n.\n\n\nmovie-resolver.service.ts\n\n\n\nimport\n \n{\n \nInjectable\n \n}\n \nfrom\n \n@angular/core\n;\n\n\nimport\n \n{\n \nActivatedRoute\n,\n \nRouter\n,\n \nResolve\n \n}\n \nfrom\n \n@angular/router\n;\n\n\n\n@Injectable\n()\n\n\nexport\n \nclass\n \nMovieResolver\n \nimplements\n \nResolve\nIMovie\n \n{\n\n  \nconstructor\n(\n\n    \nprivate\n \n_movieService\n: \nMovieService\n,\n\n    \nprivate\n \n_router\n: \nRouter\n,\n\n    \nprivate\n \n_route\n: \nActivatedRoute\n)\n \n{}\n\n\n  \nresolve() {\n\n    \nlet\n \nid\n \n=\n \n+\nthis\n.\n_route\n.\nsnapshot\n.\nparams\n[\nid\n];\n\n    \nlet\n \nmovie\n \n=\n \nthis\n.\n_movieService\n.\ngetEvent\n(\nid\n);\n\n    \nif\n \n(\nmovie\n)\n \n{\n\n      \nreturn\n \nmovie\n;\n\n    \n}\n \nelse\n \n{\n \n// id not found\n\n      \nthis\n.\nrouter\n.\nnavigate\n([\n/movies\n]);\n\n      \nreturn\n \nnull\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n/movie.service.ts\n\n\n\n@Injectable\n()\n\n\nexport\n \nclass\n \nMovieService\n \n{\n\n  \ngetMovie\n(\nid\n: \nnumber\n)\n:\n \nIMovie\n \n{\n\n    \nlet\n \nsubject\n \n=\n \nnew\n \nSubject\n();\n\n    \nlet\n \nmovie\n \n=\n \nMOVIES\n.\nfind\n(\nmovie\n \n=\n \nmovie\n.\nid\n \n===\n \nid\n);\n\n    \nsetTimeout\n(()\n \n=\n \n{\n \nsubject\n.\nnext\n(\nmovie\n);\n \nsubject\n.\ncomplete\n()\n \n},\n \n2000\n);\n\n    \nreturn\n \nsubject\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\nroutes.ts\n\n\n\n...\n\n\nexport\n \nconst\n \nappRoutes\n: \nRoutes\n \n=\n \n[\n\n  \n...\n\n  \n{\n \npath\n:\n \nmovies\n,\n \ncomponent\n: \nMovieListComponent\n \n},\n\n  \n{\n \npath\n:\n\n    \nmovie/:id\n,\n\n    \ncomponent\n: \nMovieDetailComponent\n,\n\n    \nresolve\n:\n \n{\n \nmovieData\n: \nMovieResolver\n \n}\n \n},\n\n  \n...\n\n\n];\n\n\n\n\n\n\nNote that the returned data of \nMovieResolver\n is assigned to \nmovieData\n. Then, on the Component, \nmovieData\n is retrieved from the route snapshot array.\n\n\nmovie.component.ts\n\n\n\n...\n\n\nexport\n \nclass\n \nMoviesComponent\n \nimplements\n \nOnInit\n \n{\n\n  \nmovie\n: \nIMovie\n;\n\n\n  \nconstructor\n(\n\n    \nprivate\n \nmovieService\n: \nMovieService\n,\n\n    \nprivate\n \n_route\n: \nActivatedRoute\n)\n \n{}\n\n\n  \nngOnInit() {\n\n    \nthis\n.\nmovie\n \n=\n \nthis\n.\n_route\n.\nsnapshot\n.\ndata\n[\nmovieData\n];\n\n  \n}\n\n\n}\n\n\n\n\n\n\napp.module.ts\n\n\n\n@NgModule\n({\n\n  \n...\n\n  \nproviders\n:\n \n[\n\n    \n...\n\n    \nMovieResolver\n,\n\n  \n]\n\n\n})\n\n\nexport\n \nclass\n \nAppModule\n \n{\n \n}", 
            "title": "Routing & Navigation"
        }, 
        {
            "location": "/routing/#routing-navigation-basics", 
            "text": "src/index.html  base   href = /   Most routing applications should add a  base  element to the  index.html  as the first child in the  head  tag to tell the router how to compose navigation URLs.  app.module.ts  import   {   RouterModule ,   Routes   }   from   @angular/router ;  import   {   appRoutes   }   from   ./routes ;  @NgModule ({ \n   imports :   [ \n     ... \n     RouterModule . forRoot ( appRoutes ,   {   enableTracing :  true   }) \n   ]  })  export   class   AppModule   {   }   routes.ts  ...  import   {   Routes   }   from   @angular/router ;  export   const   appRoutes :  Routes   =   [ \n   {   path :   movies ,   component :  MovieListComponent   }, \n   {   path :   movie/:id ,   component :  MovieDetailComponent   }, \n   {   path :   welcome ,   component :  WelcomeComponent   }, \n   {   path :   ,   redirectTo :   welcome   pathMatch :   full   }, \n   {   path :   ** ,   component :  PageNotFoundComponent   },  ];   The  appRoutes  array of  routes  describes how to navigate. Pass it to the  RouterModule.forRoot  method in the module  imports  to configure the router.  Each  Route  maps a URL  path  to a component. There are  no leading slashes  in the  path . The router parses and builds the final URL for you, allowing you to use both relative and absolute paths when navigating between application views.  The  :id  in the second route is a token for a route parameter. In a URL such as  /movie/42 , \"42\" is the value of the  id  parameter. The corresponding  MovieDetailComponent  will use that value to find and present the movie whose  id  is 42. You'll learn more about route parameters later in this guide.  The  data  property in the third route is a place to store arbitrary data associated with this specific route. The data property is accessible within each activated route. Use it to store items such as page titles, breadcrumb text, and other read-only,  static  data. You'll use the resolve guard to retrieve  dynamic  data later in the guide.  The  empty path  in the fourth route represents the default path for the application, the place to go when the path in the URL is empty, as it typically is at the start. This default route redirects to the route for the  /movies  URL and, therefore, will display the  MoviesListComponent .  The  **  path in the last route is a  wildcard . The router will select this route if the requested URL doesn't match any paths for routes defined earlier in the configuration. This is useful for displaying a \"404 - Not Found\" page or redirecting to another route.  The order of the routes in the configuration matters  and this is by design. The router uses a  first-match wins  strategy when matching routes, so more specific routes should be placed above less specific routes. In the configuration above, routes with a static path are listed first, followed by an empty path route, that matches the default route. The wildcard route comes last because it matches  every URL  and should be selected  only  if no other routes are matched first.  If you need to see what events are happening during the navigation lifecycle, there is the  enableTracing  option as part of the router's default configuration. This outputs each router event that took place during each navigation lifecycle to the browser console. This should only be used for  debugging  purposes. You set the  enableTracing: true  option in the object passed as the second argument to the  RouterModule.forRoot()  method.", 
            "title": "Routing &amp; Navigation Basics"
        }, 
        {
            "location": "/routing/#router-outlet", 
            "text": "src/app/app.component.html  h1 Angular Router / h1  router-outlet / router-outlet   router-outlet  acts as a placeholder that Angular dynamically fills based on the current router state.", 
            "title": "Router outlet"
        }, 
        {
            "location": "/routing/#routerlinks", 
            "text": "src/app/app.component.html  h1 Angular Router / h1  nav \n   a   routerLink = /movies   routerLinkActive = active Movies / a \n   a \n     [ routerLink ]= [ / movie ,   movie . id ] \n     routerLinkActive = active \n     [ routerLinkActiveOptions ]={ exact:true }   {{ movie.name }} / a  / nav  router-outlet / router-outlet   The  RouterLink  directives on the anchor tags give the router control over those elements. The navigation paths are fixed, so you can assign a string to the  routerLink  (a \"one-time\" binding).  Had the navigation path been more dynamic, you could have bound to a template expression that returned an array of route link parameters (the  link parameters array ). The router resolves that array into a complete URL.  The  RouterLinkActive  directive on each anchor tag helps visually distinguish the anchor for the currently selected \"active\" route. The router adds the  active  CSS class to the element when the associated  RouterLink  becomes active. You can add this directive to the anchor or to its parent element.", 
            "title": "Router&nbsp;Links"
        }, 
        {
            "location": "/routing/#reading-parameters-snapshot", 
            "text": "movie.component.ts  import   {   ActivatedRoute   }   from   @angular/router ;  ...  export   class   MovieComponent   implements   OnInit   { \n   constructor ( private   _route :  ActivatedRoute )   {   } \n\n   ngOnInit () :   void   { \n     let   id   =   + this . _route . snapshot . params [ id ]; \n   }  }   When you know for certain that an instance of a  Component  will  never, never, ever  be re-used, you can simplify the code with the  snapshot .  The  route.snapshot  provides the initial value of the route parameter map. You can access the parameters directly without subscribing or adding observable operators. It's much simpler to write and read:  Remember:  you only get the  initial  value of the parameter map with this technique. Stick with the observable  paramMap  approach if there's even a chance that the parameter will change without leaving the page.", 
            "title": "Reading Parameters: snapshot"
        }, 
        {
            "location": "/routing/#routing-programmatically", 
            "text": "movie.component.ts  import   {   Router   }   from   @angular/router ; \n   ...  export   class   MovieComponent   { \n   constructor ( private   _router :  Router )   {   } \n\n   onBack () :   void   { \n     this . _router . navigate ([ movies ]); \n   }  }", 
            "title": "Routing programmatically"
        }, 
        {
            "location": "/routing/#guards", 
            "text": "You can add  guards  to the route configuration to handle scenarios such as:   Perhaps the user is not authorized to navigate to the target component.  Maybe the user must login ( authenticate ) first.  Maybe you should fetch some data before you display the target component.  You might want to save pending changes before leaving a component.  You might ask the user if it's OK to discard pending changes rather than save them.   A guard's return value controls the router's behavior:   If it returns  true , the navigation process continues.  If it returns  false , the navigation process stops and the user stays put.   The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.  The router supports multiple guard interfaces:    CanActivate  to mediate navigation  to  a route.    CanActivateChild  to mediate navigation  to  a child route.    CanDeactivate  to mediate navigation  away  from the current route.    Resolve  to perform route data retrieval  before  route activation.    CanLoad  to mediate navigation  to  a feature module loaded  asynchronously .    For creating Route Guards, we can use a Service or a Function. On the following examples, a  CanActivate  Service is used to check if the id of a movie exists. A  CanDeactivate  function is used to prevent the user navigating away from the new movies form if the form is dirty.  routes.ts  ...  import   {   MovieGuard   }   from   ./movies/movie-guard.service.ts ;  import   {   checkDirtyState   }   from   ./movies/chech-dirty.ts ;  export   const   appRoutes :  Routes   =   [ \n   {   path : \n     movie/new , \n     component :  MovieListComponent , \n     canDeactivate :   [ canDeactivateCreateMovieGuard ] \n   }, \n   {   path :   movies ,   component :  MovieListComponent   }, \n   {   path : \n     movie/:id , \n     component :  MovieDetailComponent , \n     canActivate :   [   MovieGuard   ]   }, \n   {   path :   404 ,   component :  Error404Component   }, \n   {   path :   ,   redirectTo :   welcome   pathMatch :   full   }, \n   {   path :   ** ,   redirectTo :   404   },  ];   The  MovieGuard  Service and the  canDeactivateCreateMovieGuard  function should be added as providers.  app.module.ts  import   {   MovieGuard   }   from   ./movies/movie-guard.service.ts ;  @NgModule ({ \n   ... \n   providers :   [ \n     ... \n     MovieGuard , \n     { \n       provide :   canDeactivateCreateMovieGuard , \n       useValue :  checkDirtyState \n     } \n   ]  })  export   class   AppModule   {   }", 
            "title": "Guards"
        }, 
        {
            "location": "/routing/#canactivate", 
            "text": "Service used as the CanActivate Guard.  movie-guard.service.ts  import   {   ActivatedRouteSnapshot ,   CanActivate ,   Router   }   from   @angular/router ;  import   {   Injectable   }   from   @angular/core ;  import   {   MovieService   }   from   ../shared.movie.service ;  @Injectable ()  export   class   MovieGuard   implements   CanActivate   { \n   constructor   ( \n     private   _movieService : MovieService , \n     private   _router : Router \n     )   {} \n\n   canActivate ( route : ActivatedRouteSnapshot )   { \n     const   movieExists   =   !! this . _movieService . getMovie ( + route . params [ id ]); \n\n     if   ( ! movieExists )   { \n       this . _router . navigate ([ 404 ]); \n     } \n     return   movieExists ; \n   }  }", 
            "title": "CanActivate"
        }, 
        {
            "location": "/routing/#candeactivate", 
            "text": "Function used as the CanDeactivate Guard.  chech-dirty.ts  export   function   checkDirtyState ( component : CreateMovieComponent )   { \n   if   ( component . isDirty )   { \n     return   window . confirm ( Really want to cancel? ); \n   } \n   return   true ;  }   create-movie.component.ts  @Component ({ \n   selector :   create-movie , \n   template :   `...`  })  export   class   CreateMovieComponent   { \n   isDirty :  boolean   =   true ; \n\n   constructor   ( private   _router :  Router )   {} \n\n   cancel() { \n     this . _router . navigate ([ /movies ]); \n   }  }", 
            "title": "CanDeactivate"
        }, 
        {
            "location": "/routing/#resolve", 
            "text": "If you were using a real world API, there might be some delay before the data to display is returned from the server. You don't want to display a blank component while waiting for the data.  It's preferable to pre-fetch data from the server so it's ready the moment the route is activated. This also allows you to handle errors before routing to the component. There's no point in navigating to a Movie detail for an  id  that doesn't have a record. It'd be better to send the user back to the  Movies List  that shows only valid Movies.  In summary, you want to delay rendering the routed component until all necessary data have been fetched.  You need a  resolver .  movie-resolver.service.ts  import   {   Injectable   }   from   @angular/core ;  import   {   ActivatedRoute ,   Router ,   Resolve   }   from   @angular/router ;  @Injectable ()  export   class   MovieResolver   implements   Resolve IMovie   { \n   constructor ( \n     private   _movieService :  MovieService , \n     private   _router :  Router , \n     private   _route :  ActivatedRoute )   {} \n\n   resolve() { \n     let   id   =   + this . _route . snapshot . params [ id ]; \n     let   movie   =   this . _movieService . getEvent ( id ); \n     if   ( movie )   { \n       return   movie ; \n     }   else   {   // id not found \n       this . router . navigate ([ /movies ]); \n       return   null ; \n     } \n   }  }   /movie.service.ts  @Injectable ()  export   class   MovieService   { \n   getMovie ( id :  number ) :   IMovie   { \n     let   subject   =   new   Subject (); \n     let   movie   =   MOVIES . find ( movie   =   movie . id   ===   id ); \n     setTimeout (()   =   {   subject . next ( movie );   subject . complete ()   },   2000 ); \n     return   subject ; \n   }  }   routes.ts  ...  export   const   appRoutes :  Routes   =   [ \n   ... \n   {   path :   movies ,   component :  MovieListComponent   }, \n   {   path : \n     movie/:id , \n     component :  MovieDetailComponent , \n     resolve :   {   movieData :  MovieResolver   }   }, \n   ...  ];   Note that the returned data of  MovieResolver  is assigned to  movieData . Then, on the Component,  movieData  is retrieved from the route snapshot array.  movie.component.ts  ...  export   class   MoviesComponent   implements   OnInit   { \n   movie :  IMovie ; \n\n   constructor ( \n     private   movieService :  MovieService , \n     private   _route :  ActivatedRoute )   {} \n\n   ngOnInit() { \n     this . movie   =   this . _route . snapshot . data [ movieData ]; \n   }  }   app.module.ts  @NgModule ({ \n   ... \n   providers :   [ \n     ... \n     MovieResolver , \n   ]  })  export   class   AppModule   {   }", 
            "title": "Resolve"
        }, 
        {
            "location": "/forms/", 
            "text": "Template-driven Forms\n\n\nTemplate-driven forms allow you to build the form on the HTML template. \n\n\nYou place HTML form controls (such as \ninput\n and \nselect\n) in the component template and bind them to data model properties in the component, using directives like \nngModel\n.\n\n\nYou don't create Angular form control objects. Angular directives create them for you, using the information in your data bindings. You don't push and pull data values. Angular handles that for you with \nngModel\n. Angular updates the mutable data model with user changes as they happen.\n\n\nAn Angular form has two parts: an HTML-based template and a component class to handle data and user interactions programmatically. \n\n\nsrc/app/hero-form.component.ts\n\n\n\nimport\n \n{\n \nComponent\n \n}\n \nfrom\n \n@angular/core\n;\n\n\nimport\n \n{\n \nHero\n \n}\n    \nfrom\n \n./hero\n;\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nhero-form\n,\n\n  \ntemplateUrl\n:\n \n./hero-form.component.html\n\n\n})\n\n\nexport\n \nclass\n \nHeroFormComponent\n \n{\n\n\n  \npowers\n \n=\n \n[\nReally Smart\n,\n \nSuper Flexible\n,\n\n            \nSuper Hot\n,\n \nWeather Changer\n];\n\n\n  \nmodel\n \n=\n \nnew\n \nHero\n(\n18\n,\n \nDr IQ\n,\n \nthis\n.\npowers\n[\n0\n],\n \nChuck Overstreet\n);\n\n\n  \nsubmitted\n \n=\n \nfalse\n;\n\n\n  \nonSubmit\n(\nformValues\n)\n \n{\n \n    \nthis\n.\nsubmitted\n \n=\n \ntrue\n;\n\n    \nconsole\n.\nlog\n(\nformValues\n);\n\n  \n}\n\n\n  \n// TODO: Remove this when we\nre done\n\n  \nget\n \ndiagnostic() {\n \nreturn\n \nJSON\n.\nstringify\n(\nthis\n.\nmodel\n);\n \n}\n\n\n}\n\n\n\n\n\n\nBecause template-driven forms are in their own module, you need to add the \nFormsModule\n to the array of \nimports\n for the application module before you can use forms.\n\n\nsrc/app/app.module.ts\n\n\n\n...\n\n\nimport\n \n{\n \nFormsModule\n \n}\n \nfrom\n \n@angular/forms\n;\n\n\nimport\n \n{\n \nHeroFormComponent\n \n}\n \nfrom\n \n./hero-form.component\n;\n\n\n\n@NgModule\n({\n\n  \nimports\n:\n \n[\n\n    \n...\n\n    \nFormsModule\n\n  \n],\n\n  \ndeclarations\n:\n \n[\n\n    \nAppComponent\n,\n\n    \nHeroFormComponent\n\n  \n]\n\n  \n...\n\n\n})\n\n\nexport\n \nclass\n \nAppModule\n \n{\n \n}\n\n\n\n\n\n\nhero-form.component.html\n\n\n\ndiv\n \nclass\n=\ncontainer\n\n  \nh1\nHero Form\n/\nh1\n\n\n  \nform\n \n#\nheroForm\n=\nngForm\n \n(\nngSubmit\n)=\nonSubmit\n(\nheroForm\n.\nvalue\n)\n    \n\n    \ndiv\n \nclass\n=\nform-group\n\n      \nlabel\n \nfor\n=\nname\nName\n/\nlabel\n\n      \ninput\n \ntype\n=\ntext\n \nclass\n=\nform-control\n \nid\n=\nname\n\n            \nrequired\n\n\n            \n[(\nngModel\n)]=\nmodel\n.\nname\n \nname\n=\nname\n\n\n    \n/\ndiv\n\n\n    \ndiv\n \nclass\n=\nform-group\n\n      \nlabel\n \nfor\n=\nalterEgo\nAlter Ego\n/\nlabel\n\n      \ninput\n \ntype\n=\ntext\n  \nclass\n=\nform-control\n \nid\n=\nalterEgo\n\n            \n[(\nngModel\n)]=\nmodel\n.\nalterEgo\n \nname\n=\nalterEgo\n\n    \n/\ndiv\n\n\n    \ndiv\n \nclass\n=\nform-group\n\n      \nlabel\n \nfor\n=\npower\nHero Power\n/\nlabel\n\n      \nselect\n \nclass\n=\nform-control\n  \nid\n=\npower\n\n              \nrequired\n\n              \n[(\nngModel\n)]=\nmodel\n.\npower\n \nname\n=\npower\n\n        \noption\n \n*\nngFor\n=\nlet pow of powers\n \n[\nvalue\n]=\npow\n{{pow}}\n/\noption\n\n      \n/\nselect\n\n    \n/\ndiv\n\n\n    \nbutton\n \ntype\n=\nsubmit\n \nclass\n=\nbtn btn-success\n\n      \n[\ndisabled\n]=\n!\nheroForm\n.\nform\n.\nvalid\nSubmit\n/\nbutton\n\n  \n/\nform\n\n  {{diagnostic}}\n\n/\ndiv\n\n\n\n\n\n\nIn template driven forms, if you've imported \nFormsModule\n, you don't have to do anything to the \nform\n tag in order to make use of \nFormsModule\n. Continue on to see how this works.\n\n\nThe variable \nheroForm\n is now a reference to the \nNgForm\n directive that governs the form as a whole.\n\n\n\n\nThe NgForm directive\n\n\nThe NgForm directive supplements the form element with additional features. It holds the controls you created for the elements with an \nngModel\n directive and \nname\n attribute, and monitors their properties, including their validity. It also has its own valid property which is true only if every contained control is valid.\n\n\n\n\nNotice that you also added a \nname\n attribute to the \ninput\n tag and set it to \"name\", which makes sense for the hero's name. Any unique value will do, but using a descriptive name is helpful. Defining a \nname\n attribute is a requirement when using \n[(ngModel)]\n in combination with a form.\n\n\n\n\nInternally, Angular creates \nFormControl\n instances and registers them with an \nNgForm\n directive that Angular attached to the \nform\n tag. Each \nFormControl\n is registered under the name you assigned to the \nname\n attribute.\n\n\n\n\nngModelGroup\n\n\nCreates and binds a \nFormGroup\n instance to a DOM element.\n\n\nThis directive can only be used as a child of \nNgForm\n (or in other words,\nwithin \nform\n tags).\n\n\nUse this directive if you'd like to create a sub-group within a form. This can\ncome in handy if you want to validate a sub-group of your form separately from\nthe rest of your form, or if some values in your domain model make more sense to\nconsume together in a nested object.\n\n\nPass in the name you'd like this sub-group to have and it will become the key\nfor the sub-group in the form's full value. You can also export the directive into\na local template variable using \nngModelGroup\n (ex: \n#myGroup=\"ngModelGroup\"\n).\n\n\nimport\n \n{\nComponent\n}\n \nfrom\n \n@angular/core\n;\n\n\nimport\n \n{\nNgForm\n}\n \nfrom\n \n@angular/forms\n;\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nexample-app\n,\n\n  \ntemplate\n:\n \n`\n\n\n    \nform #f=\nngForm\n (ngSubmit)=\nonSubmit(f)\n\n\n      \np *ngIf=\nnameCtrl.invalid\nName is invalid.\n/p\n\n\n\n      \ndiv ngModelGroup=\nname\n #nameCtrl=\nngModelGroup\n\n\n        \ninput name=\nfirst\n [ngModel]=\nname.first\n minlength=\n2\n\n\n        \ninput name=\nlast\n [ngModel]=\nname.last\n required\n\n\n      \n/div\n\n\n\n      \ninput name=\nemail\n ngModel\n \n\n\n      \nbutton\nSubmit\n/button\n\n\n    \n/form\n\n\n\n    \nbutton (click)=\nsetValue()\nSet value\n/button\n\n\n  `\n,\n\n\n})\n\n\nexport\n \nclass\n \nNgModelGroupComp\n \n{\n\n  \nname\n \n=\n \n{\nfirst\n:\n \nNancy\n,\n \nlast\n:\n \nDrew\n};\n\n\n  \nonSubmit\n(\nf\n: \nNgForm\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nf\n.\nvalue\n);\n  \n// {name: {first: \nNancy\n, last: \nDrew\n}, email: \n}\n\n    \nconsole\n.\nlog\n(\nf\n.\nvalid\n);\n  \n// true\n\n  \n}\n\n\n  \nsetValue() {\n \nthis\n.\nname\n \n=\n \n{\nfirst\n:\n \nBess\n,\n \nlast\n:\n \nMarvin\n};\n \n}\n\n\n}\n\n\n\n\n\n\nTemplate-driven validation\n\n\nTo add validation to a template-driven form, you add the same validation attributes as you\nwould with \nnative HTML form validation\n.\nAngular uses directives to match these attributes with validator functions in the framework.\n\n\nYou can then inspect the control's state by exporting \nngModel\n to a local template variable.\nThe following example exports \nNgModel\n into a variable called \nname\n:\n\n\ntemplate/hero-form-template.component.html (name)\n\n\n\ninput\n \nid\n=\nname\n \nname\n=\nname\n \nclass\n=\nform-control\n\n       \nrequired\n \nminlength\n=\n4\n \nforbiddenName\n=\nbob\n\n\n       \n[(\nngModel\n)]=\nhero\n.\nname\n \n#\nname\n=\nngModel\n \n\n\n\n\ndiv\n \n*\nngIf\n=\nname.invalid \n (name.dirty || name.touched)\n\n     \nclass\n=\nalert alert-danger\n\n  \ndiv\n \n*\nngIf\n=\nname.errors.required\n\n    Name is required.\n  \n/\ndiv\n\n  \ndiv\n \n*\nngIf\n=\nname.errors.minlength\n\n    Name must be at least 4 characters long.\n  \n/\ndiv\n\n  \ndiv\n \n*\nngIf\n=\nname.errors.forbiddenName\n\n    Name cannot be Bob.\n  \n/\ndiv\n\n\n/\ndiv\n\n\n\n\n\n\n\n\nWhy check \ndirty\n and \ntouched\n?\n\n\nYou may not want your application to display errors before the user has a chance to edit the form.\nThe checks for \ndirty\n and \ntouched\n prevent errors from showing until the user\ndoes one of two things: changes the value,\nturning the control dirty; or blurs the form control element, setting the control to touched.\n\n\n\n\nReactive Forms\n\n\nAngular \nreactive\n forms facilitate a \nreactive style\n of programming\nthat favors explicit management of the data flowing between\na non-UI \ndata model\n (typically retrieved from a server) and a\nUI-oriented \nform model\n that retains the states\nand values of the HTML controls on screen. Reactive forms offer the ease\nof using reactive patterns, testing, and validation.\n\n\nWith \nreactive\n forms, you create a tree of Angular form control objects\nin the component class and bind them to native form control elements in the\ncomponent template, using techniques described below.\n\n\nsrc/app/hero-detail.component.ts\n\n\n\nimport\n \n{\n \nComponent\n \n}\n   \nfrom\n \n@angular/core\n;\n\n\nimport\n \n{\n \nFormControl\n,\n \nFormGroup\n \n}\n \nfrom\n \n@angular/forms\n;\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nhero-detail\n,\n\n  \ntemplateUrl\n:\n \n./hero-detail.component.html\n\n\n})\n\n\nexport\n \nclass\n \nHeroDetailComponent\n \n{\n\n\n  \nheroForm\n \n=\n \nnew\n \nFormGroup\n \n({\n\n\n    \nname\n: \nnew\n \nFormControl\n(\n,\n \nValidators\n.\nrequired\n)\n\n\n  \n});\n\n\n}\n\n\n\n\n\n\nA \nFormControl\n constructor accepts three, optional arguments: the initial data value, an array of validators, and an array of async validators.\n\n\nsrc/app/hero-detail.component.html\n\n\n\nh2\nHero Detail\n/\nh2\n\n\nh3\ni\nFormControl in a FormGroup\n/\ni\n/\nh3\n\n\nform\n \n[\nformGroup\n]=\nheroForm\n \nnovalidate\n\n\n  \ndiv\n \nclass\n=\nform-group\n\n    \nlabel\n \nclass\n=\ncenter-block\nName:\n\n      \ninput\n \nclass\n=\nform-control\n \nformControlName\n=\nname\n\n\n    \n/\nlabel\n\n  \n/\ndiv\n\n\n/\nform\n\n\n\n\n\n\nsrc/app/app.module.ts\n\n\n\n...\n\n\nimport\n \n{\n \nReactiveFormsModule\n \n}\n \nfrom\n \n@angular/forms\n;\n \n\n\n\nimport\n \n{\n \nAppComponent\n \n}\n        \nfrom\n \n./app.component\n;\n\n\nimport\n \n{\n \nHeroDetailComponent\n \n}\n \nfrom\n \n./hero-detail.component\n;\n\n\n\n@NgModule\n({\n\n  \nimports\n:\n \n[\n\n    \nBrowserModule\n,\n\n\n    \nReactiveFormsModule\n\n\n  \n],\n\n  \ndeclarations\n:\n \n[\n\n    \nAppComponent\n,\n\n    \nHeroDetailComponent\n,\n\n  \n],\n\n  \nbootstrap\n:\n \n[\n \nAppComponent\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nAppModule\n \n{\n \n}\n\n\n\n\n\n\nEssential form classes\n\n\n\n\n\n\nAbstractControl\n is the abstract base class for the three concrete form control classes: \nFormControl\n, \nFormGroup\n, and \nFormArray\n. It provides their common behaviors and properties, some of which are \nobservable\n.\n\n\n\n\n\n\nFormControl\n tracks the value and validity status of an \nindividual\n form control. It corresponds to an HTML form control such as an input box or selector.\n\n\n\n\n\n\nFormGroup\n tracks the value and validity state of a \ngroup\n of \nAbstractControl\n instances. The group's properties include its child controls.\n    The top-level form in your component is a \nFormGroup\n.\n\n\n\n\n\n\nFormArray\n tracks the value and validity state of a numerically indexed \narray\n of \nAbstractControl\n instances.\n\n\n\n\n\n\nIntroduction to \nFormBuilder\n\n\nThe \nFormBuilder\n class helps reduce repetition and clutter by handling details of control creation for you.\n\n\nsrc/app/hero-detail.component.ts\n\n\n\nimport\n \n{\n \nComponent\n \n}\n \nfrom\n \n@angular/core\n;\n\n\nimport\n \n{\n \nFormBuilder\n,\n \nFormGroup\n,\n \nValidators\n \n}\n \nfrom\n \n@angular/forms\n;\n\n\n\n@Component\n({\n\n  \nselector\n:\n \nhero-detail\n,\n\n  \ntemplateUrl\n:\n \n./hero-detail.component.html\n\n\n})\n\n\nexport\n \nclass\n \nHeroDetailComponent3\n \n{\n\n  \nheroForm\n: \nFormGroup\n;\n\n\n\n  \nconstructor\n(\nprivate\n \nfb\n: \nFormBuilder\n)\n \n{\n\n\n    \nthis\n.\ncreateForm\n();\n\n  \n}\n\n\n  \ncreateForm() {\n\n\n    \nthis\n.\nheroForm\n \n=\n \nthis\n.\nfb\n.\ngroup\n({\n\n\n      \nname\n:\n \n[\n,\n \nValidators\n.\nrequired\n \n],\n \n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nNested FormGroups\n\n\nYou can group some of the related \nFormControls\n into a nested \nFormGroup\n. The \nstreet\n, \ncity\n, \nstate\n, and \nzip\n are properties that would make a good \naddress\n \nFormGroup\n. Nesting groups and controls in this way allows you to\nmirror the hierarchical structure of the data model and helps track validation and state for related sets of controls.\n\n\nsrc/app/hero-detail.component.ts\n\n\n\nexport\n \nclass\n \nHeroDetailComponent5\n \n{\n\n  \nheroForm\n: \nFormGroup\n;\n\n  \nstates\n \n=\n \nstates\n;\n\n\n  \nconstructor\n(\nprivate\n \nfb\n: \nFormBuilder\n)\n \n{\n\n    \nthis\n.\ncreateForm\n();\n\n  \n}\n\n\n  \ncreateForm() {\n\n    \nthis\n.\nheroForm\n \n=\n \nthis\n.\nfb\n.\ngroup\n({\n \n// \n-- the parent FormGroup\n\n      \nname\n:\n \n[\n,\n \nValidators\n.\nrequired\n \n],\n\n      \naddress\n: \nthis.fb.group\n({\n \n// \n-- the child FormGroup\n\n        \nstreet\n:\n \n,\n\n        \ncity\n:\n \n,\n\n        \nstate\n:\n \n,\n\n        \nzip\n:\n \n\n      \n}),\n\n      \npower\n:\n \n,\n\n      \nsidekick\n:\n \n\n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nsrc/app/hero-detail.component.html\n\n\n\nh2\nHero Detail\n/\nh2\n\n\nh3\ni\nA FormGroup with multiple FormControls\n/\ni\n/\nh3\n\n\nform\n \n[\nformGroup\n]=\nheroForm\n \nnovalidate\n\n  \ndiv\n \nclass\n=\nform-group\n\n    \nlabel\n \nclass\n=\ncenter-block\nName:\n      \ninput\n \nclass\n=\nform-control\n \nformControlName\n=\nname\n\n    \n/\nlabel\n\n  \n/\ndiv\n\n\n  \ndiv\n \nformGroupName\n=\naddress\n \nclass\n=\nwell well-lg\n\n\n    \nh4\nSecret Lair\n/\nh4\n\n    \ndiv\n \nclass\n=\nform-group\n\n      \nlabel\n \nclass\n=\ncenter-block\nStreet:\n        \ninput\n \nclass\n=\nform-control\n \nformControlName\n=\nstreet\n\n      \n/\nlabel\n\n    \n/\ndiv\n\n    \ndiv\n \nclass\n=\nform-group\n\n      \nlabel\n \nclass\n=\ncenter-block\nCity:\n        \ninput\n \nclass\n=\nform-control\n \nformControlName\n=\ncity\n\n      \n/\nlabel\n\n    \n/\ndiv\n\n    \ndiv\n \nclass\n=\nform-group\n\n      \nlabel\n \nclass\n=\ncenter-block\nState:\n        \nselect\n \nclass\n=\nform-control\n \nformControlName\n=\nstate\n\n          \noption\n \n*\nngFor\n=\nlet state of states\n \n[\nvalue\n]=\nstate\n{{state}}\n/\noption\n\n        \n/\nselect\n\n      \n/\nlabel\n\n    \n/\ndiv\n\n    \ndiv\n \nclass\n=\nform-group\n\n      \nlabel\n \nclass\n=\ncenter-block\nZip Code:\n        \ninput\n \nclass\n=\nform-control\n \nformControlName\n=\nzip\n\n      \n/\nlabel\n\n    \n/\ndiv\n\n  \n/\ndiv\n\n  \ndiv\n \nclass\n=\nform-group radio\n\n    \nh4\nSuper power:\n/\nh4\n\n    \nlabel\n \nclass\n=\ncenter-block\ninput\n \ntype\n=\nradio\n \nformControlName\n=\npower\n \nvalue\n=\nflight\nFlight\n/\nlabel\n\n    \nlabel\n \nclass\n=\ncenter-block\ninput\n \ntype\n=\nradio\n \nformControlName\n=\npower\n \nvalue\n=\nx-ray vision\nX-ray vision\n/\nlabel\n\n    \nlabel\n \nclass\n=\ncenter-block\ninput\n \ntype\n=\nradio\n \nformControlName\n=\npower\n \nvalue\n=\nstrength\nStrength\n/\nlabel\n\n  \n/\ndiv\n\n  \ndiv\n \nclass\n=\ncheckbox\n\n    \nlabel\n \nclass\n=\ncenter-block\n\n      \ninput\n \ntype\n=\ncheckbox\n \nformControlName\n=\nsidekick\nI have a sidekick.\n    \n/\nlabel\n\n  \n/\ndiv\n\n\n/\nform\n\n\n\n\n\n\nPopulate the form model with setValue and patchValue\n\n\nsetValue\n\n\nWith \nsetValue\n, you assign \nevery\n form control value \nat once\n by passing in a data object whose properties exactly match the \nform model\n behind the \nFormGroup\n.\n\n\nsrc/app/hero-detail.component.ts\n\n\n\nthis\n.\nheroForm\n.\nsetValue\n({\n\n  \nname\n:    \nthis.hero.name\n,\n\n  \naddress\n: \nthis.hero.addresses\n[\n0\n]\n \n||\n \nnew\n \nAddress\n()\n\n\n});\n\n\n\n\n\n\nThe \nsetValue\n method checks the data object thoroughly before assigning any form control values.\n\n\nIt will not accept a data object that doesn't match the FormGroup structure or is\nmissing values for any control in the group. This way, it can return helpful\nerror messages if you have a typo or if you've nested controls incorrectly.\n\npatchValue\n will fail silently.\n\n\nOn the other hand,\nsetValue\n will catch the error and report it clearly.\n\n\npatchValue\n\n\nWith \npatchValue\n, you can assign values to specific controls in a \nFormGroup\n\nby supplying an object of key/value pairs for just the controls of interest.\n\n\nThis example sets only the form's \nname\n control.\n\n\nsrc/app/hero-detail.component.ts\n\n\n\nthis\n.\nheroForm\n.\npatchValue\n({\n\n  \nname\n: \nthis.hero.name\n\n\n});\n\n\n\n\n\n\nWith \npatchValue\n you have more flexibility to cope with wildly divergent data and form models. But unlike \nsetValue\n,  \npatchValue\n cannot check for missing control values and does not throw helpful errors.", 
            "title": "Forms"
        }, 
        {
            "location": "/forms/#template-driven-forms", 
            "text": "Template-driven forms allow you to build the form on the HTML template.   You place HTML form controls (such as  input  and  select ) in the component template and bind them to data model properties in the component, using directives like  ngModel .  You don't create Angular form control objects. Angular directives create them for you, using the information in your data bindings. You don't push and pull data values. Angular handles that for you with  ngModel . Angular updates the mutable data model with user changes as they happen.  An Angular form has two parts: an HTML-based template and a component class to handle data and user interactions programmatically.   src/app/hero-form.component.ts  import   {   Component   }   from   @angular/core ;  import   {   Hero   }      from   ./hero ;  @Component ({ \n   selector :   hero-form , \n   templateUrl :   ./hero-form.component.html  })  export   class   HeroFormComponent   { \n\n   powers   =   [ Really Smart ,   Super Flexible , \n             Super Hot ,   Weather Changer ]; \n\n   model   =   new   Hero ( 18 ,   Dr IQ ,   this . powers [ 0 ],   Chuck Overstreet ); \n\n   submitted   =   false ; \n\n   onSubmit ( formValues )   {  \n     this . submitted   =   true ; \n     console . log ( formValues ); \n   } \n\n   // TODO: Remove this when we re done \n   get   diagnostic() {   return   JSON . stringify ( this . model );   }  }   Because template-driven forms are in their own module, you need to add the  FormsModule  to the array of  imports  for the application module before you can use forms.  src/app/app.module.ts  ...  import   {   FormsModule   }   from   @angular/forms ;  import   {   HeroFormComponent   }   from   ./hero-form.component ;  @NgModule ({ \n   imports :   [ \n     ... \n     FormsModule \n   ], \n   declarations :   [ \n     AppComponent , \n     HeroFormComponent \n   ] \n   ...  })  export   class   AppModule   {   }   hero-form.component.html  div   class = container \n   h1 Hero Form / h1     form   # heroForm = ngForm   ( ngSubmit )= onSubmit ( heroForm . value )           div   class = form-group \n       label   for = name Name / label \n       input   type = text   class = form-control   id = name \n             required               [( ngModel )]= model . name   name = name       / div \n\n     div   class = form-group \n       label   for = alterEgo Alter Ego / label \n       input   type = text    class = form-control   id = alterEgo \n             [( ngModel )]= model . alterEgo   name = alterEgo \n     / div \n\n     div   class = form-group \n       label   for = power Hero Power / label \n       select   class = form-control    id = power \n               required \n               [( ngModel )]= model . power   name = power \n         option   * ngFor = let pow of powers   [ value ]= pow {{pow}} / option \n       / select \n     / div \n\n     button   type = submit   class = btn btn-success \n       [ disabled ]= ! heroForm . form . valid Submit / button \n   / form \n  {{diagnostic}} / div   In template driven forms, if you've imported  FormsModule , you don't have to do anything to the  form  tag in order to make use of  FormsModule . Continue on to see how this works.  The variable  heroForm  is now a reference to the  NgForm  directive that governs the form as a whole.   The NgForm directive  The NgForm directive supplements the form element with additional features. It holds the controls you created for the elements with an  ngModel  directive and  name  attribute, and monitors their properties, including their validity. It also has its own valid property which is true only if every contained control is valid.   Notice that you also added a  name  attribute to the  input  tag and set it to \"name\", which makes sense for the hero's name. Any unique value will do, but using a descriptive name is helpful. Defining a  name  attribute is a requirement when using  [(ngModel)]  in combination with a form.   Internally, Angular creates  FormControl  instances and registers them with an  NgForm  directive that Angular attached to the  form  tag. Each  FormControl  is registered under the name you assigned to the  name  attribute.", 
            "title": "Template-driven Forms"
        }, 
        {
            "location": "/forms/#ngmodelgroup", 
            "text": "Creates and binds a  FormGroup  instance to a DOM element.  This directive can only be used as a child of  NgForm  (or in other words,\nwithin  form  tags).  Use this directive if you'd like to create a sub-group within a form. This can\ncome in handy if you want to validate a sub-group of your form separately from\nthe rest of your form, or if some values in your domain model make more sense to\nconsume together in a nested object.  Pass in the name you'd like this sub-group to have and it will become the key\nfor the sub-group in the form's full value. You can also export the directive into\na local template variable using  ngModelGroup  (ex:  #myGroup=\"ngModelGroup\" ).  import   { Component }   from   @angular/core ;  import   { NgForm }   from   @angular/forms ;  @Component ({ \n   selector :   example-app , \n   template :   `       form #f= ngForm  (ngSubmit)= onSubmit(f)         p *ngIf= nameCtrl.invalid Name is invalid. /p         div ngModelGroup= name  #nameCtrl= ngModelGroup           input name= first  [ngModel]= name.first  minlength= 2           input name= last  [ngModel]= name.last  required         /div         input name= email  ngModel           button Submit /button       /form       button (click)= setValue() Set value /button    ` ,  })  export   class   NgModelGroupComp   { \n   name   =   { first :   Nancy ,   last :   Drew }; \n\n   onSubmit ( f :  NgForm )   { \n     console . log ( f . value );    // {name: {first:  Nancy , last:  Drew }, email:  } \n     console . log ( f . valid );    // true \n   } \n\n   setValue() {   this . name   =   { first :   Bess ,   last :   Marvin };   }  }", 
            "title": "ngModelGroup"
        }, 
        {
            "location": "/forms/#template-driven-validation", 
            "text": "To add validation to a template-driven form, you add the same validation attributes as you\nwould with  native HTML form validation .\nAngular uses directives to match these attributes with validator functions in the framework.  You can then inspect the control's state by exporting  ngModel  to a local template variable.\nThe following example exports  NgModel  into a variable called  name :  template/hero-form-template.component.html (name)  input   id = name   name = name   class = form-control \n        required   minlength = 4   forbiddenName = bob          [( ngModel )]= hero . name   # name = ngModel     div   * ngIf = name.invalid   (name.dirty || name.touched) \n      class = alert alert-danger \n   div   * ngIf = name.errors.required \n    Name is required.\n   / div \n   div   * ngIf = name.errors.minlength \n    Name must be at least 4 characters long.\n   / div \n   div   * ngIf = name.errors.forbiddenName \n    Name cannot be Bob.\n   / div  / div    Why check  dirty  and  touched ?  You may not want your application to display errors before the user has a chance to edit the form.\nThe checks for  dirty  and  touched  prevent errors from showing until the user\ndoes one of two things: changes the value,\nturning the control dirty; or blurs the form control element, setting the control to touched.", 
            "title": "Template-driven validation"
        }, 
        {
            "location": "/forms/#reactive-forms", 
            "text": "Angular  reactive  forms facilitate a  reactive style  of programming\nthat favors explicit management of the data flowing between\na non-UI  data model  (typically retrieved from a server) and a\nUI-oriented  form model  that retains the states\nand values of the HTML controls on screen. Reactive forms offer the ease\nof using reactive patterns, testing, and validation.  With  reactive  forms, you create a tree of Angular form control objects\nin the component class and bind them to native form control elements in the\ncomponent template, using techniques described below.  src/app/hero-detail.component.ts  import   {   Component   }     from   @angular/core ;  import   {   FormControl ,   FormGroup   }   from   @angular/forms ;  @Component ({ \n   selector :   hero-detail , \n   templateUrl :   ./hero-detail.component.html  })  export   class   HeroDetailComponent   {     heroForm   =   new   FormGroup   ({       name :  new   FormControl ( ,   Validators . required )     });  }   A  FormControl  constructor accepts three, optional arguments: the initial data value, an array of validators, and an array of async validators.  src/app/hero-detail.component.html  h2 Hero Detail / h2  h3 i FormControl in a FormGroup / i / h3  form   [ formGroup ]= heroForm   novalidate     div   class = form-group \n     label   class = center-block Name:        input   class = form-control   formControlName = name       / label \n   / div  / form   src/app/app.module.ts  ...  import   {   ReactiveFormsModule   }   from   @angular/forms ;    import   {   AppComponent   }          from   ./app.component ;  import   {   HeroDetailComponent   }   from   ./hero-detail.component ;  @NgModule ({ \n   imports :   [ \n     BrowserModule ,       ReactiveFormsModule     ], \n   declarations :   [ \n     AppComponent , \n     HeroDetailComponent , \n   ], \n   bootstrap :   [   AppComponent   ]  })  export   class   AppModule   {   }", 
            "title": "Reactive Forms"
        }, 
        {
            "location": "/forms/#essential-form-classes", 
            "text": "AbstractControl  is the abstract base class for the three concrete form control classes:  FormControl ,  FormGroup , and  FormArray . It provides their common behaviors and properties, some of which are  observable .    FormControl  tracks the value and validity status of an  individual  form control. It corresponds to an HTML form control such as an input box or selector.    FormGroup  tracks the value and validity state of a  group  of  AbstractControl  instances. The group's properties include its child controls.\n    The top-level form in your component is a  FormGroup .    FormArray  tracks the value and validity state of a numerically indexed  array  of  AbstractControl  instances.", 
            "title": "Essential form classes"
        }, 
        {
            "location": "/forms/#introduction-to-formbuilder", 
            "text": "The  FormBuilder  class helps reduce repetition and clutter by handling details of control creation for you.  src/app/hero-detail.component.ts  import   {   Component   }   from   @angular/core ;  import   {   FormBuilder ,   FormGroup ,   Validators   }   from   @angular/forms ;  @Component ({ \n   selector :   hero-detail , \n   templateUrl :   ./hero-detail.component.html  })  export   class   HeroDetailComponent3   { \n   heroForm :  FormGroup ;     constructor ( private   fb :  FormBuilder )   {       this . createForm (); \n   } \n\n   createForm() {       this . heroForm   =   this . fb . group ({         name :   [ ,   Validators . required   ],  \n     }); \n   }  }", 
            "title": "Introduction to FormBuilder"
        }, 
        {
            "location": "/forms/#nested-formgroups", 
            "text": "You can group some of the related  FormControls  into a nested  FormGroup . The  street ,  city ,  state , and  zip  are properties that would make a good  address   FormGroup . Nesting groups and controls in this way allows you to\nmirror the hierarchical structure of the data model and helps track validation and state for related sets of controls.  src/app/hero-detail.component.ts  export   class   HeroDetailComponent5   { \n   heroForm :  FormGroup ; \n   states   =   states ; \n\n   constructor ( private   fb :  FormBuilder )   { \n     this . createForm (); \n   } \n\n   createForm() { \n     this . heroForm   =   this . fb . group ({   //  -- the parent FormGroup \n       name :   [ ,   Validators . required   ], \n       address :  this.fb.group ({   //  -- the child FormGroup \n         street :   , \n         city :   , \n         state :   , \n         zip :   \n       }), \n       power :   , \n       sidekick :   \n     }); \n   }  }   src/app/hero-detail.component.html  h2 Hero Detail / h2  h3 i A FormGroup with multiple FormControls / i / h3  form   [ formGroup ]= heroForm   novalidate \n   div   class = form-group \n     label   class = center-block Name:\n       input   class = form-control   formControlName = name \n     / label \n   / div     div   formGroupName = address   class = well well-lg       h4 Secret Lair / h4 \n     div   class = form-group \n       label   class = center-block Street:\n         input   class = form-control   formControlName = street \n       / label \n     / div \n     div   class = form-group \n       label   class = center-block City:\n         input   class = form-control   formControlName = city \n       / label \n     / div \n     div   class = form-group \n       label   class = center-block State:\n         select   class = form-control   formControlName = state \n           option   * ngFor = let state of states   [ value ]= state {{state}} / option \n         / select \n       / label \n     / div \n     div   class = form-group \n       label   class = center-block Zip Code:\n         input   class = form-control   formControlName = zip \n       / label \n     / div \n   / div \n   div   class = form-group radio \n     h4 Super power: / h4 \n     label   class = center-block input   type = radio   formControlName = power   value = flight Flight / label \n     label   class = center-block input   type = radio   formControlName = power   value = x-ray vision X-ray vision / label \n     label   class = center-block input   type = radio   formControlName = power   value = strength Strength / label \n   / div \n   div   class = checkbox \n     label   class = center-block \n       input   type = checkbox   formControlName = sidekick I have a sidekick.\n     / label \n   / div  / form", 
            "title": "Nested FormGroups"
        }, 
        {
            "location": "/forms/#populate-the-form-model-with-setvalue-and-patchvalue", 
            "text": "", 
            "title": "Populate the form model with setValue and patchValue"
        }, 
        {
            "location": "/forms/#setvalue", 
            "text": "With  setValue , you assign  every  form control value  at once  by passing in a data object whose properties exactly match the  form model  behind the  FormGroup .  src/app/hero-detail.component.ts  this . heroForm . setValue ({ \n   name :     this.hero.name , \n   address :  this.hero.addresses [ 0 ]   ||   new   Address ()  });   The  setValue  method checks the data object thoroughly before assigning any form control values.  It will not accept a data object that doesn't match the FormGroup structure or is\nmissing values for any control in the group. This way, it can return helpful\nerror messages if you have a typo or if you've nested controls incorrectly. patchValue  will fail silently.  On the other hand, setValue  will catch the error and report it clearly.", 
            "title": "setValue"
        }, 
        {
            "location": "/forms/#patchvalue", 
            "text": "With  patchValue , you can assign values to specific controls in a  FormGroup \nby supplying an object of key/value pairs for just the controls of interest.  This example sets only the form's  name  control.  src/app/hero-detail.component.ts  this . heroForm . patchValue ({ \n   name :  this.hero.name  });   With  patchValue  you have more flexibility to cope with wildly divergent data and form models. But unlike  setValue ,   patchValue  cannot check for missing control values and does not throw helpful errors.", 
            "title": "patchValue"
        }, 
        {
            "location": "/angular-cli/", 
            "text": "Angular CLI is a Command Line Interface (CLI) to automate your development workflow. It allows you to:\n\n\n\n\ncreate a new Angular application\n\n\nrun a development server with LiveReload support to preview your application during development\n\n\nadd features to your existing Angular application\n\n\nrun your application\u2019s unit tests\n\n\nrun your application\u2019s end-to-end (E2E) tests\n\n\nbuild your application for deployment to production\n\n\n\n\nAngular CLI does not just blindly generate code for you. It uses static analysis to better understand the semantics of your application. For example, when adding a new component using \nng generate component\n, Angular CLI finds the closest module in the module tree of your application and integrates the new feature in that module. So if you have an application with multiple modules, Angular CLI will automatically integrate the new feature in the correct module, depending on the directory where you run the command from.\n\n\nInstalling Angular CLI\n\n\n$ npm install -g @angular/cli\n\n\n\n\n\nCreating and Runnning a New Angular Application\n\n\nThere are two ways to create a new application using Angular CLI:\n\n\n\n\nng init\n: create a new application in the current directory\n\n\nng new\n: create a new directory and run \nng init\n inside the new directory\n\n\n\n\nSo \nng new\n is similar to \nng init\n except that it also creates a directory for you.\n\n\n$ ng new my-app\n\n\n\n\n\nOptions:\n\n\n\n\n--dry-run\n: boolean, default \nfalse\n, perform dry-run so no changes are written to filesystem\n\n\n--verbose\n: boolean, default \nfalse\n\n\n--link-cli\n: boolean, default \nfalse\n, automatically link the \n@angular/cli\n package (\nmore info\n)\n\n\n--skip-install\n: boolean, default \nfalse\n, skip \nnpm install\n\n\n--skip-git\n: boolean, default \nfalse\n, don\u2019t initialize git repository\n\n\n--skip-tests\n: boolean, default \nfalse\n, skip creating tests\n\n\n--skip-commit\n: boolean, default \nfalse\n, skip committing the first git commit\n\n\n--directory\n: string, name of directory to create, by default this is the same as the application name\n\n\n--source-dir\n: string, default \n'src'\n, name of source directory\n\n\n--style\n: string, default \n'css'\n, the style language to use (\n'css'\n, \n'less'\n or \n'scss'\n)\n\n\n--prefix\n: string, default \n'app'\n, the prefix to use when generating new components\n\n\n--mobile\n: boolean, default \nfalse\n, generate a Progressive Web App application\n\n\n--routing\n: boolean, default \nfalse\n, add module with routing information and import it in main app module\n\n\n--inline-style\n: boolean, default \nfalse\n, use inline styles when generating the new application\n\n\n--inline-template\n: boolean, default \nfalse\n, use inline templates when generating the new application\n\n\n\n\nTo run the app:\n\n\n$ \ncd\n my-app\n$ ng serve\n\n\n\n\n\nAdding Features\n\n\n\n\nng generate class my-new-class\n: add a class to your application\n\n\nng generate component my-new-component\n: add a component to your application\n\n\nng generate directive my-new-directive\n: add a directive to your application\n\n\nng generate enum my-new-enum\n: add an enum to your application\n\n\nng generate module my-new-module\n: add a module to your application\n\n\nng generate pipe my-new-pipe\n: add a pipe to your application\n\n\nng generate service my-new-service\n: add a service to your application\n\n\n\n\nThe \ngenerate\n command and the different sub-commands also have shortcut notations, so the following commands are similar:\n\n\n\n\nng g cl my-new-class\n: add a class to your application\n\n\nng g c my-new-component\n: add a component to your application\n\n\nng g d my-new-directive\n: add a directive to your application\n\n\nng g e my-new-enum\n: add an enum to your application\n\n\nng g m my-new-module\n: add a module to your application\n\n\nng g p my-new-pipe\n: add a pipe to your application\n\n\nng g s my-new-service\n: add a service to your application\n\n\n\n\nRun \n$ ng generate --help\n to see all available options of your locally installed Angular CLI.\n\n\nAdding a new Class\n\n\n$ ng generate class user-profile\n\n\n\n\n\nOptions:\n\n\n\n\n--spec\n: boolean, default \nfalse\n, generate spec file with unit test\n\n\n\n\nAdding a new Component\n\n\n$ ng generate component site-header\n\n\n\n\n\nOptions:\n\n\n\n\n--flat\n: boolean, default \nfalse\n, generate component files in \nsrc/app\n instead of \nsrc/app/site-header\n\n\n--inline-template\n: boolean, default \nfalse\n, use an inline template instead of a separate HTML file\n\n\n--inline-style\n: boolean, default \nfalse\n, use inline styles instead of a separate CSS file\n\n\n--prefix\n: boolean, default \ntrue\n, use prefix specified in \n.angular-cli.json\n in component selector\n\n\n--spec\n: boolean, default \ntrue\n, generate spec file with unit test\n\n\n--view-encapsulation\n: string, specifies the view encapsulation strategy\n\n\n--change-detection\n: string, specifies the change detection strategy\n\n\n\n\nAdding a new Directive\n\n\n$ ng generate directive admin-link\n\n\n\n\n\nOptions:\n\n\n\n\n--flat\n: boolean, default \ntrue\n, generate directive files in \nsrc/app\n instead of \nsrc/app/admin-link\n\n\n--prefix\n: boolean, default \ntrue\n, use prefix specified in \n.angular-cli.json\n in directive selector\n\n\n--spec\n: boolean, default \ntrue\n, generate spec file with unit test\n\n\n\n\nAdding a new enum\n\n\n$ ng generate enum direction\n\n\n\n\n\nAdding a new Module\n\n\n$ ng generate module admin\n\n\n\n\n\nOptions:\n\n\n\n\n--routing\n: boolean, default \nfalse\n, generate an additional module \nAdminRoutingModule\n with just the routing information and add it as an import to your new module\n\n\n--spec\n: boolean, default \nfalse\n, add \nsrc/app/admin/admin.module.spec.ts\n with a unit test that checks whether the module exists\n\n\n\n\nAdding a new Pipe\n\n\n$ ng generate pipe convert-to-euro\n\n\n\n\n\nOptions:\n\n\n\n\n--flat\n: boolean, default \ntrue\n, generate component files in \nsrc/app\n instead of \nsrc/app/convert-to-euro\n\n\n--spec\n: boolean, default \ntrue\n, generate spec file with unit test\n\n\n\n\nAdding a new Service\n\n\n$ ng generate service backend-api\n\n\n\n\n\nOptions:\n\n\n\n\n--flat\n: boolean, default \ntrue\n, generate service file in \nsrc/app\n instead of \nsrc/app/backend-api\n\n\n--spec\n: boolean, default \ntrue\n, generate spec file with unit test\n\n\n\n\nTests\n\n\nRunning Unit Tests\n\n\n$ ng \ntest\n\n\n\n\n\n\nRunning End-to-end (E2E) Tests\n\n\n$ ng e2e\n\n\n\n\n\nBuilding App for Production\n\n\nRunning \nng serve\n builds and bundles your Angular application automatically to a virtual filesystem during development.\n\n\nHowever, when your application is ready for production, you will need real files that you can deploy to your server or to the cloud.\n\n\nTo build and bundle your application for deployment, run:\n\n\n$ ng build\n\n\n\n\n\nOptions:\n\n\n\n\n--aot\n: enable ahead-of-time compilation\n\n\n--base-href\n: string, the base href to use in the index file\n\n\n--environment\n: string, default \ndev\n, environment to use\n\n\n--output-path\n: string, directory to write the output to\n\n\n--target\n: string, default \ndevelopment\n, environment to use\n\n\n--watch\n: boolean, default \nfalse\n, watch files for changes and rebuild when a change is detected\n\n\n\n\nTargets\n\n\nSpecifying a target impacts the way the build process operates. Its value can be one of the following:\n\n\n\n\ndevelopment\n: default mode, do not minify or uglify code\n\n\nproduction\n: minify and uglify code\n\n\n\n\nEnvironments\n\n\nEnvironments let you specify settings to customize your application behavior.\n\n\nYou can define your own environments in the \n.angular-cli.json\n file. The default ones are:\n\n\n\n\nsource\n: use settings defined in \nenvironments/environment.ts\n\n\ndev\n: use settings defined in \nenvironments/environment.ts\n\n\nprod\n: use settings defined in \nenvironments/environment.prod.ts\n\n\n\n\nThe Angular CLI section is an excerpt from \nwww.sitepoint.com/ultimate-angular-cli-reference/\n by Jurgen Van de Moere (\n@jvandemo\n).", 
            "title": "Angular CLI"
        }, 
        {
            "location": "/angular-cli/#installing-angular-cli", 
            "text": "$ npm install -g @angular/cli", 
            "title": "Installing Angular CLI"
        }, 
        {
            "location": "/angular-cli/#creating-and-runnning-a-new-angular-application", 
            "text": "There are two ways to create a new application using Angular CLI:   ng init : create a new application in the current directory  ng new : create a new directory and run  ng init  inside the new directory   So  ng new  is similar to  ng init  except that it also creates a directory for you.  $ ng new my-app  Options:   --dry-run : boolean, default  false , perform dry-run so no changes are written to filesystem  --verbose : boolean, default  false  --link-cli : boolean, default  false , automatically link the  @angular/cli  package ( more info )  --skip-install : boolean, default  false , skip  npm install  --skip-git : boolean, default  false , don\u2019t initialize git repository  --skip-tests : boolean, default  false , skip creating tests  --skip-commit : boolean, default  false , skip committing the first git commit  --directory : string, name of directory to create, by default this is the same as the application name  --source-dir : string, default  'src' , name of source directory  --style : string, default  'css' , the style language to use ( 'css' ,  'less'  or  'scss' )  --prefix : string, default  'app' , the prefix to use when generating new components  --mobile : boolean, default  false , generate a Progressive Web App application  --routing : boolean, default  false , add module with routing information and import it in main app module  --inline-style : boolean, default  false , use inline styles when generating the new application  --inline-template : boolean, default  false , use inline templates when generating the new application   To run the app:  $  cd  my-app\n$ ng serve", 
            "title": "Creating and Runnning a New Angular Application"
        }, 
        {
            "location": "/angular-cli/#adding-features", 
            "text": "ng generate class my-new-class : add a class to your application  ng generate component my-new-component : add a component to your application  ng generate directive my-new-directive : add a directive to your application  ng generate enum my-new-enum : add an enum to your application  ng generate module my-new-module : add a module to your application  ng generate pipe my-new-pipe : add a pipe to your application  ng generate service my-new-service : add a service to your application   The  generate  command and the different sub-commands also have shortcut notations, so the following commands are similar:   ng g cl my-new-class : add a class to your application  ng g c my-new-component : add a component to your application  ng g d my-new-directive : add a directive to your application  ng g e my-new-enum : add an enum to your application  ng g m my-new-module : add a module to your application  ng g p my-new-pipe : add a pipe to your application  ng g s my-new-service : add a service to your application   Run  $ ng generate --help  to see all available options of your locally installed Angular CLI.", 
            "title": "Adding Features"
        }, 
        {
            "location": "/angular-cli/#adding-a-new-class", 
            "text": "$ ng generate class user-profile  Options:   --spec : boolean, default  false , generate spec file with unit test", 
            "title": "Adding a new Class"
        }, 
        {
            "location": "/angular-cli/#adding-a-new-component", 
            "text": "$ ng generate component site-header  Options:   --flat : boolean, default  false , generate component files in  src/app  instead of  src/app/site-header  --inline-template : boolean, default  false , use an inline template instead of a separate HTML file  --inline-style : boolean, default  false , use inline styles instead of a separate CSS file  --prefix : boolean, default  true , use prefix specified in  .angular-cli.json  in component selector  --spec : boolean, default  true , generate spec file with unit test  --view-encapsulation : string, specifies the view encapsulation strategy  --change-detection : string, specifies the change detection strategy", 
            "title": "Adding a new Component"
        }, 
        {
            "location": "/angular-cli/#adding-a-new-directive", 
            "text": "$ ng generate directive admin-link  Options:   --flat : boolean, default  true , generate directive files in  src/app  instead of  src/app/admin-link  --prefix : boolean, default  true , use prefix specified in  .angular-cli.json  in directive selector  --spec : boolean, default  true , generate spec file with unit test", 
            "title": "Adding a new Directive"
        }, 
        {
            "location": "/angular-cli/#adding-a-new-enum", 
            "text": "$ ng generate enum direction", 
            "title": "Adding a new enum"
        }, 
        {
            "location": "/angular-cli/#adding-a-new-module", 
            "text": "$ ng generate module admin  Options:   --routing : boolean, default  false , generate an additional module  AdminRoutingModule  with just the routing information and add it as an import to your new module  --spec : boolean, default  false , add  src/app/admin/admin.module.spec.ts  with a unit test that checks whether the module exists", 
            "title": "Adding a new Module"
        }, 
        {
            "location": "/angular-cli/#adding-a-new-pipe", 
            "text": "$ ng generate pipe convert-to-euro  Options:   --flat : boolean, default  true , generate component files in  src/app  instead of  src/app/convert-to-euro  --spec : boolean, default  true , generate spec file with unit test", 
            "title": "Adding a new Pipe"
        }, 
        {
            "location": "/angular-cli/#adding-a-new-service", 
            "text": "$ ng generate service backend-api  Options:   --flat : boolean, default  true , generate service file in  src/app  instead of  src/app/backend-api  --spec : boolean, default  true , generate spec file with unit test", 
            "title": "Adding a new Service"
        }, 
        {
            "location": "/angular-cli/#tests", 
            "text": "", 
            "title": "Tests"
        }, 
        {
            "location": "/angular-cli/#running-unit-tests", 
            "text": "$ ng  test", 
            "title": "Running Unit Tests"
        }, 
        {
            "location": "/angular-cli/#running-end-to-end-e2e-tests", 
            "text": "$ ng e2e", 
            "title": "Running End-to-end (E2E) Tests"
        }, 
        {
            "location": "/angular-cli/#building-app-for-production", 
            "text": "Running  ng serve  builds and bundles your Angular application automatically to a virtual filesystem during development.  However, when your application is ready for production, you will need real files that you can deploy to your server or to the cloud.  To build and bundle your application for deployment, run:  $ ng build  Options:   --aot : enable ahead-of-time compilation  --base-href : string, the base href to use in the index file  --environment : string, default  dev , environment to use  --output-path : string, directory to write the output to  --target : string, default  development , environment to use  --watch : boolean, default  false , watch files for changes and rebuild when a change is detected", 
            "title": "Building App for Production"
        }, 
        {
            "location": "/angular-cli/#targets", 
            "text": "Specifying a target impacts the way the build process operates. Its value can be one of the following:   development : default mode, do not minify or uglify code  production : minify and uglify code", 
            "title": "Targets"
        }, 
        {
            "location": "/angular-cli/#environments", 
            "text": "Environments let you specify settings to customize your application behavior.  You can define your own environments in the  .angular-cli.json  file. The default ones are:   source : use settings defined in  environments/environment.ts  dev : use settings defined in  environments/environment.ts  prod : use settings defined in  environments/environment.prod.ts   The Angular CLI section is an excerpt from  www.sitepoint.com/ultimate-angular-cli-reference/  by Jurgen Van de Moere ( @jvandemo ).", 
            "title": "Environments"
        }, 
        {
            "location": "/3rd-party/", 
            "text": "Simply install your library via \nnpm install lib-name --save\n and import it in your code.\n\n\nIf the library does not include typings, you can install them using npm:\n\n\n$ npm install d3 --save\n$ npm install @types/d3 --save-dev\n\n\n\n\n\nThen open \nsrc/tsconfig.app.json\n and add it to the \ntypes\n array:\n\n\ntypes\n:\n[\n\n  \nd3\n\n\n]\n\n\n\n\n\n\nIf the library you added typings for is only to be used on your e2e tests, instead use \ne2e/tsconfig.e2e.json\n. The same goes for unit tests and \nsrc/tsconfig.spec.json\n.\n\n\nIf the library doesn't have typings available at \n@types/\n, you can still use it by manually adding typings for it:\n\n\n\n\nFirst, create a \ntypings.d.ts\n file in your \nsrc/\n folder. This file will be automatically included as global type definition.\n\n\n\n\nThen, in \nsrc/typings.d.ts\n, add the following code:\n\n\ndeclare module \ntypeless-package\n;\n\n\n\n\n\n\n\n\n\nFinally, in the component or file that uses the library, add the following code:\n\n\nimport\n \n*\n \nas\n \ntypelessPackage\n \nfrom\n \ntypeless-package\n;\n\n\ntypelessPackage\n.\nmethod\n();\n\n\n\n\n\n\n\n\n\n\nDone. Note: you might need or find useful to define more typings for the library that you're trying to use.\n\n\nExcerpt from \nhttps://github.com/angular/angular-cli/wiki/stories-third-party-lib\n).", 
            "title": "3rd Party Library Installation"
        }, 
        {
            "location": "/misc/", 
            "text": "Barrels\n\n\nA way to \nroll up exports\n from several ES2015 modules into a single convenient ES2015 module. The barrel itself is an ES2015 module file that re-exports \nselected\n exports of other ES2015 modules.\n\n\n// movies/movie.component.ts\n\n\nexport\n \nclass\n \nMovieComponent\n \n{}\n\n\n\n// movies/movie.model.ts\n\n\nexport\n \nclass\n \nMovie\n \n{}\n\n\n\n// movies/movie.service.ts\n\n\nexport\n \nclass\n \nMovieService\n \n{}\n\n\n\n\n\n\nWithout a barrel, a consumer needs three import statements:\n\n\nimport\n \n{\n \nMovieComponent\n \n}\n \nfrom\n \n../movies/movie.component.ts\n;\n\n\nimport\n \n{\n \nMovie\n \n}\n          \nfrom\n \n../movies/movie.model.ts\n;\n\n\nimport\n \n{\n \nMovieService\n \n}\n   \nfrom\n \n../movies/movie.service.ts\n;\n\n\n\n\n\n\nYou can add a barrel to the \nmovies\n folder (called \nindex\n, by convention) that exports all of these items:\n\n\nmovies/index.ts\n\n\n\nexport\n \n*\n \nfrom\n \n./movie.model.ts\n;\n   \n// re-export all of its exports\n\n\nexport\n \n*\n \nfrom\n \n./movie.service.ts\n;\n \n// re-export all of its exports\n\n\nexport\n \n{\n \nMovieComponent\n \n}\n \nfrom\n \n./movie.component.ts\n;\n \n// re-export the named thing\n\n\n\n\n\n\nNow a consumer can import what it needs from the barrel.\n\n\nimport\n \n{\n \nMovie\n,\n \nMovieService\n \n}\n \nfrom\n \n../movies\n;\n \n// index is implied", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/misc/#barrels", 
            "text": "A way to  roll up exports  from several ES2015 modules into a single convenient ES2015 module. The barrel itself is an ES2015 module file that re-exports  selected  exports of other ES2015 modules.  // movies/movie.component.ts  export   class   MovieComponent   {}  // movies/movie.model.ts  export   class   Movie   {}  // movies/movie.service.ts  export   class   MovieService   {}   Without a barrel, a consumer needs three import statements:  import   {   MovieComponent   }   from   ../movies/movie.component.ts ;  import   {   Movie   }            from   ../movies/movie.model.ts ;  import   {   MovieService   }     from   ../movies/movie.service.ts ;   You can add a barrel to the  movies  folder (called  index , by convention) that exports all of these items:  movies/index.ts  export   *   from   ./movie.model.ts ;     // re-export all of its exports  export   *   from   ./movie.service.ts ;   // re-export all of its exports  export   {   MovieComponent   }   from   ./movie.component.ts ;   // re-export the named thing   Now a consumer can import what it needs from the barrel.  import   {   Movie ,   MovieService   }   from   ../movies ;   // index is implied", 
            "title": "Barrels"
        }
    ]
}